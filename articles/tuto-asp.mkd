Title: Introduction à Answer Set Programming (ASP)
Date: 2017-03-31
Modified: 2017-03-31
Tags: asp, language, tuto
Authors: Lucas Bourneuf
Summary: un tuto pour ASP
Slug: tuto-asp
Lang: français
Translation: false
Status: draft


<br/>

[TOC]

<br/>


# Introduction

Cet article est un tuto qui se veut accessible sur [Answer Set Programming](https://en.wikipedia.org/wiki/Answer%20set%20programming),
un langage de programmation déclaratif implémentant la *Programmation Par Contrainte*,
ou PPC (comme java implémente la POO et haskell la PF).

Pour ceux qui connaissent, il fera certainement penser à [Prolog](http://www.learnprolognow.org/),
puisque ces deux langages reposent sur les même concepts, bien qu'ils ne l'implémentent pas de la même manière.
Pour les matheux, il fera penser à TLA+, en beaucoup moins puissant, certainement, sur le côté formalisation matheuse.

L'objectif n'est pas seulement d'apprendre les bases en faisant joujou,
mais de développer des programmes qui résolvent des problèmes de la vie réelle,
éventuellement avec quelques lignes en plus pour pouvoir être réellement utilisés dans la vie de tous les jours.

Dans une certaine mesure, ce tuto s'adresse aussi à ceux qui n'ont jamais codé ;
après tout, les langages logiques sont les meilleurs pour commencer :)
(je fais un effort de simplification durant tout le tuto,
justement pour permettre à des personnes n'ayant jamais codé de s'y intéresser)

Aussi, une grosse partie du tuto est théorique. Ce n'est peut-être pas très équilibré, surtout au début.
Si ça ne vous motive pas, [installez](#compilation) directement,
et commencez à jouer avec [l'introduction du langage](principes-danswer-set-programming).


## Quelques liens préliminaires
*Où l'on se demande pourquoi faire un tuto si c'est pour renvoyer tout le monde voir ailleurs*

Je conseille volontier la lecture parallèle d'un tuto existant ; ça aide toujours d'avoir
plusieurs sources pour comprendre un concept.
Pour être franc, je n'ai trouvé que [celui-ci](https://cjamcl.com/blog/a-gentle-introduction-to-asp/) (en anglais),
qui passe très vite sur les bases.

Les scripts utilisés ici sont disponibles
sur le dépôt [learning-ASP](https://github.com/Aluriak/learning-ASP).
Vous pouvez les télécharger, et même participer à leur développement si besoin.

Notez aussi que clingo, le groundeur/solveur que nous allons utiliser,
est accompagné [d'un manuel bien fournis](http://sourceforge.net/projects/potassco/files/guide/),
d'un [nombre impressionnant d'exemples de tous types dans ses sources](https://github.com/potassco/clingo/tree/master/examples)
(j'insiste ; faites y un tour, il y a un exemple pour presque toute les fonctionalités du solveur),
et [d'une mailing list active](https://sourceforge.net/p/potassco/mailman/potassco-users/)
où beaucoup de questions intéressantes sont posées.
(il y a [une autre mailing list](https://lists.sourceforge.net/lists/listinfo/potassco-announce)
pour les annonces des développeurs, typiquement les nouvelles versions)

Notez également que ce blog a déjà parlé d'ASP :

- [Deponia et ASP]({filename}/articles/deponia-asp.mkd) : résoudre un puzzle avec ASP
<!-- - [se-lang]({filename}/articles/se-lang.mkd) : définir des systèmes astrophysiques avec ASP -->
<!-- - [biseau]({filename}/articles/seb-biseau.mkd) : utiliser ASP comme DSL pour dessiner des graphes -->


## Prérequis
Un peu de logique. Booléenne, c'est encore mieux.
Non, sérieusement, on va parler de programmation logique ; savoir ce qu'on appelle la logique booléenne et ses principaux opérateurs est un plus.
Néanmoins, pas besoin d'une grosse connaissance : juste savoir ce que veulent dire «et» et «ou» en logique.
En clair, avoir lu les exemples introductifs de [la page wikipédia](https://fr.wikipedia.org/wiki/Alg%C3%A8bre%20de%20Boole%20(logique)), ou ceux-là qui [sont franchement pas mal](http://www.courstechinfo.be/MathInfo/FctLogiques1.html).

# Concepts généraux
*Où l'on découvre à quelle sauce nous allons être mangés*

## Principes de Programmation Déclarative
Comment collecter tous les entiers positifs inférieurs à 100 et multiples de 3 ?
En python, une manière de faire est la suivante (à droite, après le `#`, il s'agit de commentaires qui ne sont pas interprétés par la machine, qui sont là juste pour l'humain) :

```python
for nb in range(0, 100):  # pour chacun des nombres de 1 à 100
    if nb % 3 == 0:       # si le nombre est un multiple de 3
        print(nb)         # afficher le nombre à l'écran
```

Ce qu'il y a à voir ici, c'est que l'on explique au programme exécutant le code (ici, l'interpréteur python)
**comment** arriver à la solution qui nous intéresse.
Ce paradigme, dit *impératif*, consiste à expliquer **comment calculer la solution**.

C'est une approche qui est en fait assez peu naturelle, et ça se voit quand on commence la programmation.
C'est effectivement assez consternant de devoir s'expliquer auprès d'un ordinateur qui semble avoir
les capacités de compréhension d'un enfant de 5 ans (et c'est encore pire avec les langage de bas-niveau),
et c'est un gros problème dans l'enseignement en informatique.

La programmation déclarative aborde le problème d'un angle différent :
l'humain ne doit plus expliquer **comment** atteindre la solution,
mais plutôt la **décrire**,
c'est à dire répondre au **quoi**, ce qui est beaucoup plus naturel pour un humain.
Le paradigme *déclaratif* consiste en l'explication du **quoi**.

HTML est un bon exemple de langage déclaratif: on décrit bien la solution (la structure finale de la page web).
Le HTML n'est pas un langage impératif ; d'ailleurs,
si la page finale dépend de paramètres extérieurs (compte enregistré par exemple),
vous ne pouvez plus compter uniquement sur le HTML.
C'est généralement là qu'interviennent des langages *impératifs* (Javascript, PHP, Python, Java,…)
qui permettent de générer du HTML à partir de templates et des paramètres extérieurs.

Sans ces languages, il faudrait avoir en mémoire toutes les pages web possibles,
ce qui n'est pas possible pour une grande partie des sites web, et difficilement maintenable.


## Principes de Programmation Logique
Le paradigme logique est un sous-ensemble du paradigme déclaratif.
Autrement dit, un langage *logique* est un langage *déclaratif*.
À l'inverse, un langage *déclaratif* n'est pas nécessairement *logique* (le HTML, par exemple, n'est pas logique).

Le paradigme logique repose sur les méthodes formelles issues des maths et de la théorie de la logique
C'est avec ces outils que la description de la solution (la réponse au **quoi**) est formulée.

C'est précisément à cette catégorie de langage qu'ASP appartient.

Pour présenter un peu le concept de la programmation logique,
imaginons un langage qui nous permettrais d'expliquer ce qu'est
la solution au programme python vu précédemment (calculer les nombres entre 1 et 100 qui sont multiples de 3) :

```
euh… ben, tout les nombres qui sont multiple de 3, tu vois, mais
entre 1 et 100. Et puis, «nombre» oui, mais pas ceux à virgule, hein.
Ouais, décimaux, c'est ça.
```

Ce langage possède deux propriétés attractives :
la majorité des francophones le comprendrais, ET ils seraient capable de
le réutiliser pour exprimer le même problème, ou une variation
(les multiples de 4, ou les nombres de 1 à 200,… Essayez chez vous, vous verrez, c'est facile).

Le problème, c'est qu'aujourd'hui en informatique, créer un programme qui
comprendrais ce language relève encore de la science-fiction.
Hors, et c'est bien là l'objet de ce tuto, on veut utiliser l'ordinateur
(et un ordinateur de bureau, hein, pas un super calculateur et
l'équipe de chercheur en langage naturel qui va avec).

Donc, essayons maintenant de faire un language que nos petits ordinateurs puisse comprendre :

```
afficher x tel que : x est un entier, 1 < x < 100, x est un multiple de 3.
```

C'est compréhensible, simple et efficace ; c'est de la programmation logique !
Ce langage précis n'est pas implémenté (et ASP est un peu moins haut niveau (i.e. proche du langage naturel) que cela),
certes, mais il s'agit d'un exemple d'approche d'un langage expressif.
On remarque bien ici qu'il ne s'agit finalement que de *décrire* la solution.

La [page wikipédia française sur la programmation déclarative](https://fr.wikipedia.org/wiki/Programmation%20d%C3%A9clarative)
est courte, mais suffisante pour notre étude.


## Principes de Programmation Par Contrainte
Nous pouvons définir une *contrainte* comme *une restriction sur les solutions*.
En d'autres termes, la programmation par contrainte consiste
à ajouter des expressions qui écartent des solutions,
qui sinon seraient autorisées.

C'est un moyen efficace de s'assurer qu'une propriété est respectée dans toutes les solutions.

À propos de notre exemple sur les nombres de 1 à 100 divisibles par trois, nous pouvons trouver quelques contraintes :
*«seulement des nombres entiers»*, ou encore *«doit être divisible par trois»*, ou bien *«doit être inférieur à 100»*.

En vérité, les contraintes sont très naturelles dans nos langages naturels.

«*Deux joueurs ne peuvent commencer à une distance de moins de 5 mètres*» pourrait dire un designer de jeu.

«*Un taxon ne peut appartenir à deux branches*» dira le phylogénéticien.

«*Je ne peux pas mettre plus de deux packs de lait sur le support arrière du caddie*» dis-je pendant mes courses.

Bref, il est souvent plus simple d'exprimer une contrainte plutôt qu'inclure
cette restriction dans la génération de la réponse elle-même (*bon, je vais faire les courses en ne mettant pas deux packs de lait à l'arrière du caddie*).

Aussi, la contrainte est parfois moins coûteuse. Par exemple, si je cherche mon caddie dans le magasin,
je compare ceux que je vois avec les souvenirs que j'en ai : *euh, celui-là a un pack de lait à l'arrière, c'est peut-être le miens*.
Mais plus rarement, je m'amuse à inventorier ces points commun : *ya bien une conserve de ravioli, un pack de brosse à dent,…*
À la place, je fonctionne plutôt avec des contraintes : *non, c'est pas celui-ci, il n'a pas de chocolat à l'avant*.

En bref, lorsqu'on cherche quelque chose, écarter les mauvaises possibilités en trouvant une seule différence
est souvent plus rapide que d'énumérer les points communs.

En général, un langage autorisant la programmation par contrainte pourra être divisé en deux parties :

1. définir les possibles solutions (modélisation de l'espace de recherche)
2. interdire les résultats qui ne nous intéressent pas (contraintes)

La première partie, c'est la *génération*, où l'on génère les candidats pour la solution.
Comme en général ces candidats ne sont pas tous bons, on besoin de les filtrer,
d'où la seconde étape, *l'application de contraintes*,
qui permet de définir quels candidats seront écartés.
(digression-culture: ce n'est pas le seul usage des contraintes, mais on verra ça bien après)

Answer Set Programming est un langage logique où les contraintes
font partie du langage autant que le reste des déclarations.
Néanmoins, la dichotomie entre génération et contraintes se voit dans beaucoup de codes ASP,
car les développeurs ont intuitivement ce découpage dans leur réflexions.



# Outillage
*Où l'on va enfin faire quelque chose ; dommage que ce soit pas très intéressant*

Il existe [de nombreuses implémentations d'ASP](https://en.wikipedia.org/wiki/Answer%20set%20programming#Comparison%20of%20implementations),
chacunes avec des approches uniques
et intéressantes pour résoudre des problèmes plus ou moins spécifiques.

Pour ce tuto, nous allons utiliser la suite [Potassco](https://potassco.org), un ensemble de logiciels
qui gravitent autour d'une idée : implémenter et utiliser ASP.
Plus particulièrement, nous allons utiliser *clingo*.

(si ça vous motive et que vous êtes à l'aise, prenez une autre implémentation ;
en général les différences conceptuelles du langage
ne seront pas monstrueuses, mais certaines implémentations fonctionneront différemment.

Cela étant dit, suivre un tuto avec les bons outils, c'est pas plus mal.
Bref, faites comme vous voulez, mais dans le doute, utilisez clingo et explorez les autres après si l'envie vous en prend)


## Clingo, en deux (cents) mots et deux parties
Si vous ne comprenez rien au charabia de cette section, pas d'inquiétude : c'est juste pour fixer les idées des informaticiens.
Lisez tout de même, je met quelques simplifications au milieu.

Clingo est à ASP ce que CPython est à Python:
une usine à gaz (un gros programme bien compliqué) qui comprend et applique les effets de bord du langage.
<!-- Faut vraiment que je fasse un article sur ces notions -->

Clingo est en fait constitué de deux composantes: *gringo* et *clasp* (que l'on peut récupérer et utiliser à part).

Gringo est à ASP ce que [le compilateur de CPython](https://docs.python.org/3/library/dis.html) est à Python, ou ce que gcc est à C:
une grammaire et un ensemble de routines
qui compilent vers un langage simplifié à l'extrême.
(dans le cas d'ASP, c'est du [smodels](http://www.tcs.hut.fi/Software/smodels/), pour CPython c'est du bytecode, et pour C c'est de l'assembleur)

Clasp est à ASP ce que l'interpréteur de CPython est à Python :
un ensembles de routines qui pigent le langage simplifié calculé par l'outils précédent (gringo/compilateur)
et en appliquent les effets de bord (mémoire et calculs).

Pour être plus précis à propos de gringo et clasp, le premier compile un programme
qui suit la grammaire d'Answer Set Programming (et un peu plus, nous verrons cela),
et le second est une routine qui, à l'aide d'une heuristique très personnalisable,
va chercher les solutions acceptables (ou *modèles stables*) dans le programme compilé.

En ASP, on parle de *grounding* pour la partie assurée par *gringo*,
et de *solving* pour la partie assurée par *clasp*.
Clingo est donc un programme qui se charge du grounding et du solving
d'un seul coups.

De notre point de vue, c'est ça en moins à gérer, mais c'est important de s'en rendre compte,
car dans pas mal de cas il peut être intéressant de manipuler les deux indépendemment.
Mais ce sera l'objet d'un autre tuto.


## Installation
il est possible de [faire tourner clingo dans un navigateur](https://potassco.org/clingo/run/).
C'est très pratique : il n'y a rien à installer, ça marche tout seul,
pas besoin de se prendre la tête.

Si vous voulez savoir comment ce bijoux technologique est possible,
allez voir [l'issue à propos](https://github.com/potassco/clingo/issues/66),
et [mon exemple fonctionnel](https://github.com/Aluriak/webclingo-example).

Si toutefois vous préférez utiliser votre environnement de dev favori,
et que vous vous sentez de faire deux clics gauche et un clic droit,
Clingo est disponible sur le [dépôt github](https://github.com/potassco/clingo/releases).
Le site de référence étant [le site de Potassco lui-même](https://potassco.org/doc/start/).

À l'écriture de ce tuto, la version de clingo la plus récente est la 5.2.2.


### Installation manuelle
A moins que vous ne soyez concerné par l'un des quelques OS qui ont un packaging,
le plus simple est probablement de

1. Télécharger ou compiler le binaire *clingo*
2. Le mettre dans le PATH (`/usr/bin` pour les bourrins, `~/.local/bin/` pour les moins bourrins)

*Qu'est-ce que le PATH ?*
[Pour les windowsiens](http://sametmax.com/ajouter-un-chemin-a-la-variable-denvironnement-path-sous-windows/),
[pour les unxiens](http://generation-linux.fr/index.php?post/2008/10/15/Changer-les-dossiers-par-defaut-dans-le-PATH).

Personnellement, j'ai un répertoire `~/bin/` vers lequel mon PATH pointe. C'est ici que j'y ai mis
mes binaires clingo:

```
❯ ls -lA ~/bin | cut -c 50- | grep clingo
clingo521
clingo454
clingo -> clingo521
```

(clingo est un lien symbolique vers l'une des versions installée… généralement la plus récente)
<!-- [comme pour les binaires python]({filename}/articles/the-python-ecosystem.mkd) -->

### Compilation
Pour les plus à l'aise, la compilation de clingo depuis les sources est aussi possible,
et nécessaire si vous voulez une version particulière avec le support de python
ou de lua avec une version particulière (je pense à python 3, notamment)

Voici le makefile que j'utilise sous fedora pour l'update, la compilation et l'installation :

```makefile
all: update_repo compile install

install:
	cp clingo/bin/clingo ~/bin/clingo_compiled_from_repo

compile:
	cd clingo && cmake -H. -B.  -DCMAKE_BUILD_TYPE=Release -DPYTHON_LIBRARY:FILEPATH=/usr/lib64/libpython3.5m.so -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.5m -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.5m
	cd clingo && make
	cd clingo && cmake --target test -H. -B.  -DCMAKE_BUILD_TYPE=Release -DPYTHON_LIBRARY:FILEPATH=/usr/lib64/libpython3.5m.so -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.5m -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.5m
	cd clingo/app/clingo/tests && python3.5m run.py --clingo ../../../bin/clingo run

update_repo:
	cd clingo && git pull
	cd clingo && git submodule update --init --recursive
```



## Quelques tests préliminaires
*Où l'on commence à jouer, avec une retenue typique d'une centrale hydroélectrique*

Maintenant que vous avez clingo qui fonctionne, effectuons quelques
tests préliminaires pour étudier un peu l'environnement.

### Version
Pour avoir la versions de clingo, il suffit de demander: `clingo --version`.
Vous verrez quelque chose du style:

    clingo version 5.2.1
    Address model: 64-bit

    libgringo version 5.2.1
    Configuration: with Python 3.6.2, with Lua 5.3.4

    libclasp version 3.3.2 (libpotassco version 1.0.0)
    Configuration: WITH_THREADS=1
    Copyright (C) Benjamin Kaufmann

    License: The MIT License <https://opensource.org/licenses/MIT>

On peut, notamment, voir les versions de gringo et clasp utilisées,
ainsi que les supports de langages de scripts (ici python et lua sont supportés tous les deux,
ce ne sera peut-être pas votre cas, selon la manière dont vous l'avez installé/compilé/récupéré).


### Le «bytecode» d'ASP
Il est possible de voir la sortie de gringo avec l'option `--text`. Avec ce flag,
clasp ne sera pas appelé et ne sera retourné que le code simplifié issu du grounding.
(pour ceux qui passe par le navigateur : il ne semble pas y avoir d'options pour le voir, mais il existe, soyez en sûr)

Lorsque l'on utilise ASP pour un problème combinatoire, il arrive souvent que l'on
s'intéresse au grounding du programme.
C'est en effet en étudiant ce code intermédiaire qu'il sera possible de déterminer
quelles règles en ASP génèrent beaucoup de données,
et donc quelles règles sont impliquées dans un temps de solving long.


## Lancez la machine !
Lancez clingo sur les fichiers contenant les programmes de ce tuto, ou lancez le sans fichier en argument,
et tapez directement le programme, puis contrôle-D (fin de fichier).
Clingo vous répondra en fonction.

Prenez **vraiment** l'habitude de lancer les programmes, et de les trifouiller.
C'est comme ça qu'on apprend !
(pour ceux qui sont dans leur navigateur : copiez-collez les programmes dans la zone de texte, modifiez-les à l'envie, et appuyez sur *run*)

Pour bien montrer comment clingo s'utilise, voici
une session complète où j'écris un programme ASP
dans l'entrée standard de clingo (j'aurais aussi pu l'écrire directement dans l'entrée standard clingo) :

    ❯ echo "a. b." > program.lp
    ❯ clingo -n 0 program.lp
    clingo version 5.2.1
    Reading from stdin
    Solving...
    Answer: 1
    a b
    SATISFIABLE

    Models       : 1
    Calls        : 1
    Time         : 0.000s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
    CPU Time     : 0.000s

(pour ceux qui sont dans l'interface web, écrivez juste `a. b.` dans le champs de texte, et appuyez sur run)

Du point de vue de clingo, que se passe-t-il ici ?

- d'abord, clingo parse les arguments de la ligne de commande (ici `-n 0` et `program.lp`)
- il apprend que je veux *tous* les modèles, toutes les réponses possibles (`-n 0`)
- il apprend également qu'il doit considérer le programme dans le fichier `program.lp`
- il lance gringo sur le programme, et obtient le code compilé (smodels).
- il lance clasp sur le code compilé, et m'affiche le résultat.
- j'apprend que mon programme n'a qu'une seule et unique solution (*Answer: 1*), où les atomes *a* et *b* sont vrais.
- j'apprend que le problème est satisfiable (évidemment, il y a eu une solution)
- clingo me donne quelques infos statistiques sur l'opération (notamment à propos du temps écoulé)

Notez que la ligne `Reading from program.lp` correspond au grounding, et la suivante, `Solving...`, correspond au solving.

Si clingo semble ne rien faire après avoir écrit la première, c'est que le grounding est long (et le pc ne fait pas *rien* ;
vous avez probablement un CPU qui tourne à 100% pendant toute la durée du grounding).
Dans l'autre cas, c'est le solveur qui pédale dans la semoule : votre problème est très long à traiter.


### help et options diverses
Vous pouvez avoir l'aide de clingo avec l'option `--help` (ou `--help=3` pour l'aide complète ; encore une fois, ceux qui sont sur le navigateur ne peuvent pas lancer ces commandes,… désolé).
Quelques options intéressantes dont je ne parlerais pas ou peu :

- `--text`: pour avoir le code groundé (le solveur, clasp, n'est pas appelé). Cf `--mode`.
- `--stats`: pour avoir plus d'info sur le déroulement du solving lorsque celui-ci est terminé (il y a une checkbox sur l'interface web)
- `--time-limit`: permet de donner un temps maximum de grounding/solving
- `--parallel-mode`: utiliser le multithreading : utiliser plusieurs cœurs en même temps pour le solving
- `--enum-mode`: choix de l'énumération des modèles : *tous les modèles*, ou *tous les meilleurs modèles* par exemple
- `--outf`: choix du format de sortie (l'un des plus intéressant est probablement JSON, si vous voulez récupérer le résultat sans faire de parsing manuel)


# Principes d'Answer Set Programming
*Où l'on va (enfin !) faire quelque chose de significatif dans ce monde où seule l'action prime*

Maintenant que l'on a plein de théorie dans la tête et clingo sur le pc,
attaquons le vif du sujet: parler ASP !

## Commentaires
Les commentaires sont des parties du texte que clingo ne va pas considérer.
Pour le dire autrement, vous pouvez mettre les pires cochonneries dans des commentaires,
clingo ne se formalisera pas.
En général, c'est très utilisé par les humains pour expliquer
à quoi sert le code qui est à côté.
Utiliser les commentaires aide à comprendre ce que fait un code ; il est donc conseillé d'utiliser les commentaires pour s'aider soi-même.

Les commentaires commencent par un `%`:

```asp
% Je suis un commentaire
Je ne suis pas un commentaire  % ni de l'ASP valide d'ailleurs
```

Ici, clingo plante sur `Je ne suis pas un commentaire`, car il ne s'agit pas d'ASP valide. Comme indiqué dans le commentaire à droite.

Les commentaires multilignes commencent avec `%*` et terminent avec `*%`.
Notez que clingo n'est pas capable de gérer la présence d'un `%*`
dans un commentaire multiligne, ni ne considère ce qu'il y a après un `%`,
empêchant d'utiliser le snippet `% *%` comme le `//*/` en C.


## Les atomes
Un atome est un fait, une relation qui est considérée vraie.
Par défaut, tout atome est considéré faux, jusqu'à ce
qu'il soit explicitement statué comme vrai.

Un programme ASP repose sur ce principe,
si bien que la solution à un problème est en fait décrite
par les atomes vérifiés.

Tout le jeu d'un programme ASP est de définir quels atomes doivent être vrais,
sous quelles conditions (c'est la modélisation du problème),
et quelles combinaisons d'atomes rendent une réponse caduque (c'est le job des contraintes).

Considérons le programme suivant:

```asp
a.
```

Ici, on indique que le *fait* `a` est vrai.
À l'inverse, tout autre fait est faux, et si on lance clingo sur ce programme,
nous ne trouverons qu'un seul et unique modèle (ou (ensemble-)réponse) : celui où `a` est vrai.

Le point `.` est un peu comme le point-virgule en C,
ou le saut de ligne en Python : il termine chaque règle et atome du programme.
Si vous oubliez un point, vous aurez droit à une erreur de type `unexpected machin-bidule bla bla bla ASP pas content`.

```asp
a(4).
```

Cette déclaration est un peu plus complexe, mais revient au même : le prédicat `a` d'arité 1
(c'est-à-dire avec 1 argument) avec comme premier (et unique) argument `4`, est vrai.

De la même manière, il est possible de déclarer `b`, `b(42)`, mais aussi `a(b)`, `a(a,b,c,3)`, `a(b(1))`, ou encore `a(a(b(b(9))))`.
Le nombre d'argument potentiel est virtuellement illimité, et un atome peut être argument d'un autre.

L'usage typique des arguments, c'est de donner des valeurs à un concept, par exemple:

```
papa(jacques_dutronc,thomas_dutronc).  % J. Dutronc est le papa de T. Dutronc
papa(dark_vador,luke_skywalker).  % Pareil pour dark vador et luke
papa(chronos,zeus).  % idem
papa(zeus,athena).  % bref, vous avez compris
papa(zeus,hercule).
papa(geb,isis).
papa(geb,nephtys).
papa(geb,osiris).
papa(zurg,buzz).
```

Voilà, toutes ces données sont considérées vraies par clingo (et en plus sont vraies dans réalité véritable, que demander de plus ?).
Bien sûr, on ne va pas s'amuser à les mettre dans tous les programmes qu'on utilise :
ça a beau être vrai, ce n'est pas toujours pertinent.


## Notation
`a/1` est l'ensemble des atomes de prédicat `a` avec un seul argument. Par exemple `a(1)` ou `a(a(a(staying,alive)))`.
De la même manière, `ha(do,pi)` et `ha(do,ken)` appartiennent tout deux à l'ensemble des atomes décrits par `ha/2`.

Questions (sans piège) : comment décrire l'atome `k(2,"mille",v(2))` ?
`coucou` ?
Et `symballium(v,o,l,u,m,e," ",i,v,"<3")` ?

(si vous n'êtes pas sûr de vos réponses, allez voir la fin de page)


## Retour sur les atomes
Ci-après, un autre programme qui génère des atomes
(donc, des *faits*, des éléments considérés vrais pendant le solving).

```asp
% Les atomes nb(X) sont vrais pour tout X entier de 1 à 100.
nb(-23..42).
% Les atomes nb_ex(X) sont vrais pour tout X ∈ [1;4]
nb_ex(1;2;3;4).
% On peut aussi combiner les deux:
nb_cb(1;2;3..10).
```

Donnez ce programme directement à manger à clingo !
Vous comprendrez vite comment ça fonctionne.


## Règles
Maintenant que l'on peut déclarer des faits, nous pouvons commencer à déclarer
des règles de causalité.
En d'autres termes, il est possible de définir qu'un atome est vrai sous certaines conditions.

En ASP, cela se fait avec l'opérateur `:-`, une espèce de *si* :

```asp
% l'atome ok est vrai SI l'atome a est vrai
ok :- a.
% l'atome ok est vrai SI les atomes b ET c sont vrais
ok :- b ; c.  % notez que le ET est symbolisé par le point-virgule
```

On appelle la partie *avant* le `:-` la *tête* (head),
et la partie à droite le *corps* (body).
La tête est vraie si et uniquement si le corps est vrai.

Les règles sont les premiers éléments utiles dans un programme ASP.
Ce sont ces règles qui vont permettre d'exprimer des implications,
et donc de réellement commencer à travailler sur les atomes existants.

Donc, dans un programme ASP, vous avez des atomes considérés vrais (souvent, ce sont des données du problème),
et des ensembles de règles qui vont permettrent d'inférer la véracité d'autres atomes.


## Variables
Les variables permettent d'écrire des règles plus généralistes.
Tout mot commencant par une majuscule est une variable.

Par exemple:
```asp
% l'atome ok(X) est vrai si l'atome a(X) est vrai
ok(X) :- a(X).
```

Avec ce programme, si `a(2)` est vrai, alors `ok(2)` le sera également.
Même chose pour n'importe quelle valeur de X, de `1` à `a` en passant par `-42000`, `"i have υτφ-8 characters"` ou `a(b(c(d,d(3),e(f,g(a(b,8)),0))),k20,flip,flop(py(disk)),"hello, world!")`.

Exemples de règles avec des variables :

```asp
% L'atome nb_3(X) est vrai pour tout X positif inférieur à 100 et multiple de 3.
nb_3(X) :- 0 < X ; X < 100 ; X \ 3 = 0.  % le '\' c'est pour le modulo, ou "division entière"
% l'atome entoure(X-1,X,X+1) est vrai si l'atome a(X) est vrai
entoure(X-1,X,X+1):- a(X).  % par exemple, avec a(2), ça donne entoure(1,2,3)
```

### Variable muette
La variable muette, c'est une manière de dire explicitement : *cette valeur ne m'intéresse pas*.
Par exemple, si je voulais avoir un atome d'arité 1 qui me donne les papas, indépendemment de leurs enfants,
je pourrais faire ainsi :

```
papa(P):- papa(P,E).
```

Sauf que le `E` qui sert à rien là, c'est pas très joli. Du coups, on peut le remplacer par une variable muette :

```
papa(P):- papa(P,_).  % une variable muette commence par un _ ('underscore')
```

Et voilà ! Il est bien clair pour tout le monde que le second argument ici ne nous intéresse pas.
Il faut qu'il existe, évidemment, mais la valeur exacte n'est pas pertinente dans le contexte.

Notez qu'on pourrait tout à fait se passer des variables muettes. Elles sont tout à fait optionnelle.
C'est ce qu'on appelle du *sucre syntaxique* : un truc sympa qui ne fait que simplifier la vie du programmeur.


## Exeeeeerciiiiiiice ! Tel père, tel fils
Petit exercice à faire chez vous, c'est obligatoire, sinon, lorsque vous commencerez à lire la partie suivante,
ce site s'autodétruira (offre soumise à condition).

Je vous propose simplement de reprendre la base de donnée des pères présentée plus haut
(avec `papa(jacques_dutronc,thomas_dutronc)` et les autres),
et de faire un programme qui, connaissant ces liens de parenté, va définir qui est l'enfant de qui.

En clair, si j'ai `papa(monpapa,moi).`, je veux obtenir `enfant(moi,monpapa).`.

Pour réussir ce petit tour, il faut utiliser les deux concepts vus précédemments : les règles et les variables.

### Aide
Si au bout de 20 minutes vous :

- **n'avez rien essayé :** bah quoi ? Allez-y ! **Tapez des trucs !** Si ya bien un domaine où il faut se tromper pour y arriver, c'est l'informatique ! Et l'ordi il est là pour ça vous savez ; et il aura oublié aussi tôt que vous aurez essayé autre chose. À moins que vous ne soyez détenu par un psychopathe qui vous observe et vous oblige à faire ce tuto ? Et qu'à la moindre erreur, il vous fait boire une soupe d'avocat ? Si c'est le cas, je suis désolé que ça tombe sur mon tuto, mais cela étant dit, je suis assez content d'avoir vu juste. Envoyez moi un mail quand vous serez sortit de là, hein ? Ça me rassurera. Et puis, dans votre malchance, vous avez de la chance : ya vraiment rien de *compliqué*. Nouveau, oui, mais il faut savoir sortir de sa zone de confort. Par contre, j'avoue, la soupe d'avocat c'est un peu sévère. Bref. Concentrez-vous, vous allez y arriver, faites vous confiance (par contre, dépêchez-vous, la soupe d'avocat froide, c'est encore pire ! … désolé).
- **n'avez rien essayé, malgré le fait qu'aucun psychopathe ne vous menace avec une soupe d'avocat :** là, il va falloir se lancer, hein (et revenez ensuite, hein ?).
- **toujours pas trouvé, malgré bien des tentatives :** en bas de page, ya les solutions.

### Bonus
Un atome `moi/1` permet d'indiquer qui je suis. Si mon père est Dark Vador ou l'infâme Zurg, alors l'atome `nooooooooooon` doit être vrai.


## Négation
Notez qu'il est possible d'utiliser la négation:

```asp
% l'atome ko(X) est vrai pour tout X de nb_ex(X) qui n'est pas ok(X)
ko(X):- nb_ex(X) ; not ok(X).
```

Notez que le point-virgule est utilisé comme opérateur *et*, l'équivalent de `and` en Python ou `&&` en C.

Une autre manière de voir cette règle, plus verbeuse mais plus puissante, est la suivante:
*Pour tout X tel que nb_ex(X) est vrai et ok(X) est faux, on a ko(X)*.

Cette formulation nous permettra de mieux comprendre une prochaine construction du langage.

Il n'existe pas réellement de *ou* en ASP ; il faut alors créer 2 règles, chacune implémentant un cas :

```asp
% l'atome ok(X) est vrai si nb_ex(X) ou si nb_in(X)
ok(X):- nb_ex(X).
ok(X):- nb_in(X).
```


## Disjonction (choix)
Une construction très importante en ASP est le *choix*.
Le choix consiste en un… choix. C'est dur à expliquer autrement.

Voici un exemple simple, avec le résultat donné par clingo,
qui consiste en un choix de exactement 1 parmis 3 atomes :


```
❯ echo "1 { a ; b ; c } 1." | clingo -n 0
clingo version 5.2.1
Reading from stdin
Solving...
Answer: 1
b
Answer: 2
c
Answer: 3
a
SATISFIABLE

Models       : 3
Calls        : 1
Time         : 0.000s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.000s
```

La sortie de clingo est toujours très semblable à celle-ci.
Les données importantes sont les différentes réponses possibles (et leur nombre).

(notez que sans l'option `-n 0`, seul un modèle aurait été montré. le `n`
est en fait la version courte de *nombre de modèle à afficher, ou 0 pour tous les afficher*.
Notez que, si des modèles n'ont pas été affichés à cause de cette option, clingo
le fera savoir en affichant un `+` à côté du nombre total de modèles calculés)

La première réponse (ou *modèle*, ou *answer set*, ou *ensemble réponse*),
contient uniquement l'atome b.
La seconde contient uniquement l'atome c.
Enfin, la dernière réponse contient uniquement l'atome a.


### Pourquoi pas deux en même temps ?
C'est vrai ça ! Pourquoi on pourrait pas avoir *a* et *b* en même temps par exemple ?

Résonnons par l'absurde : si on a *a* et *b* en même temps, cela veut dire que a et b sont vrais dans le même modèle.

Or, dans le programme, il est dit `1 { a ; b ; c } 1.`, c'est-à-dire qu'au moins une et qu'aau plus une
des trois valeurs entre accolades est vrai.
Si *a* et *b* sont vrais, alors il y a deux valeurs vraies parmis les valeurs entre accolades,
ce qui n'est pas possible, puisqu'il doit n'y en avoir qu'une !

En suivant la même logique, on devine qu'il ne peut pas non plus y avoir *a*, *b* et *c* en même temps,
ni aucun des trois.


### Pourquoi cet ordre ?
Parce qu'en ASP, on travaille sur des *set* (answer *set* programming).
Les *set*, *ensemble* en français, au sens mathématique du terme,
sont des ensembles **non ordonnés** d'éléments **uniques**.

Les conséquences de ces propriétés sont les suivantes :

- les réponses ne sont pas ordonnées (nous verrons que… mais c'est pour plus tard)
- un atome ne peut pas être *choisi* deux fois : soit il est vrai, soit il ne l'est pas. Il ne peut être vrai deux fois (car cela reviendrait à avoir deux fois le même élément dans un *set*)
- l'ordre des règles en ASP n'a pas d'importance (contrairement à Prolog, vous pouvez donc mélanger les lignes de votre programme sans que cela n'ait d'effet : allez-y, testez, c'est rigolo ! (nan, en vrai, c'est chiant comme une course d'escargot en ralentit pendant la nuit : il se passe rien))

Gardez cela à l'esprit, car ces propriétés sont fondamentales dans
la construction mathématique derrière ASP, et donc dans les notions que l'on va voir après.


### Retour à nos moutons
Le programme traité par clingo est le *choix* suivant : `1 { a ; b ; c } 1`,
qui se traduit *un élément parmis a, b ou c*.
Le 1 à gauche est la borne minimale, par défaut égale à zéro.
Le 1 à droite est la borne maximale, par défaut l'infini.

Si le programme avait été `2 { a ; b ; c } 2`, j'aurais également eu trois modèles/réponses,
mais leur contenu exact aurait changé:  `a b`, `b c` et `a c` sont les trois ensembles possibles de deux éléments parmis a, b et c.

De la même manière, si le programme était `{ a ; b ; c }`, j'aurais eu 8 modèles.
Et si il était `{ a ; b ; c } 2`, j'aurais eu 7 modèles.
Pourquoi 8 et 7 ? Je vous laisse tester vous-même,
vous comprendrez tout de suite.

(remarquez que tout cela n'est que pure [combinatoire](https://fr.wikipedia.org/wiki/Combinatoire))


Aller, un dernier exemple pour la route, qui montre comment avoir un seul `nb(X)` vrai pour chaque answer set:

```asp
% On choisis un nombre entre 1 et 100.
1 { nb(1..100) } 1.
```

Vous pouvez (devriez) vérifier : nous obtenons bien 100 answer sets, chacun avec sa propre valeur de nb(X).


## Exeeeeerciiiiiiice ! Mon papa c'est le meilleur
Un petit exercice tout simple : encore avec la base de donnée des papa, choisir le *Papa de l'Année*, titre honorifique
qui sera officiellement décerné lors d'une grande fête intergalactique.

Votre tache, si vous l'acceptez (et vous êtes obligés, sinon la fête est annulée et tout le monde va vous en vouloir, surtout l'infâme Zurg, et il est vachement rancunier alors je serais vous je ferais vachement gaffe), est de choisir le *Papa de l'Année*.

Bon, avec un grand pouvoir vient de grandes désillusion : les grandes fêtes intergalactique, je vous le cache pas, c'est surtout une occasion de revoir la famille lointaine et d'essayer ce nouvel alcool fort de tonton Gaston.
Du coups, quelque soit le papa que vous choisissez, il y aura des bastons et des gens qui hurlent.

Donc, comme on aime bien investir, nous, les illuminatis-de-l'espace-qu-on-contrôle-toute-la-galaxie-tavu, nous sommes dit
que ce serais pas mal d'avoir un programme qui choisi pour tout le monde. Pas de jaloux, c'est le hasard.

Du coups, allez-y : faites un programme ASP qui choisi un papa. Et nous, les illuminatis-de-l'espace-qu-on-contrôle-toute-la-galaxie-tavu,
on prendra le premier modèle (ou le second. Ou le dernier. Bref, celui qui nous arrange, mais chut c'est tip-top-secret !).

### Aide
Si au bout de 20 minutes, vous:

- **n'avez rien essayé :** j'en déduit que la soupe d'avocat est bonne. Perso, la seule fois où on en a fait, j'étais tout petit, y avait mon papa et ma maman qui avaient fait la soupe. Ben personne n'en a mangé. C'était. Vraiment. Pas. Bon. En vrai, rien qu'à l'odeur, on a tous fait des têtes bizarres. Et ensuite ma maman elle a goûté, et ensuite elle nous a défendu d'en prendre. Plus tard, dans ma fratrie, la légende racontait (racon*tait*, hein, parce que bon, maintenant on a grandit, on sait tous que je l'avais inventée juste pour faire mon intéressant, alors qu'en vrai c'était juste l'hiver) que, après que les parents l'ai jetée dans le compost, les plantes ont arrêtée de pousser pendant plusieurs mois.
- **n'avez rien essayé, mais êtes bien conscient qu'il faut se lancer, mais au font avez trop peur qu'en appuyant sur la mauvaise touche, je sorte de l'écran, bouillant de rage, en hurlant des insanités et en maudissant votre famille sur 29.3 générations :** un indice : avec deux expressions, ça se fait bien.
- **avez tout essayé, y compris de faire une méta-méta-heuristique qui contrôlait un algo génétique multi-agent qui testait des combinaisons au hasard de lettre pendant plus de 25 ans sur un supercalculateur :** il y a les solutions en bas de page, mais en vrai, c'est d'un séminaire sur le lâché prise dont vous avez besoin.


## Disjonction simple
L'écriture de la disjonction avec les accolades est une généralisation d'une écriture plus simple,
qui exprime le choix *d'exactement un* des opérandes.

```asp
a;b;c.
```

Lorsque vous lancez clingo là-dessus, vous trouverez trois modèles, un pour chacun de ces trois atomes.
Il est également possible de mettre cette construction dans le head d'une règle :

```asp
b;c:-a.
```

Ici, *b* OU *c* sera vrai si *a* est vrai.

Notez bien que `{a;b;c}` n'est pas égal à `a;b;c` !
Comme expliqué précédemment, les bornes minimales et maximales par défault dans l'écriture avec accolades
sont respectivement zéro et l'infini. Autrement dit, `a;b;c` est équivalent à `1{a;b;c}1`.


### Respect du choix
Quels sont les modèles issus de ce programme ?

```asp
1{a;b;c}1.
a;b;c.
```

Et de celui-là ?

```asp
1{a;b;c}1.
2{a;b;c}2.
```

et de celui-ci ?

```asp
1{a;b;c}1.
a :- b;c.
```

Et de celui-lô ?

```asp
a;b;c.
a;b;c.
```

Ces exemples montrent que les choix agissent comme des contraintes :
on dit qu'ils ne sont pas génératifs. Autrement dit, `a;b.` ne signifie pas que cette règle *ajoute a ou b au modèle*,
mais bien que *un modèle contient a ou b*.


## Contraintes
Les contraintes ! On en a souvent parlé,
et certainement brûlez-vous d'impatience à l'idée de les utiliser !

Reprenons un de nos derniers exemples, en ajoutant une contrainte qui écarte
tous les modèles avec une valeur qui n'est pas multiple de 3 :

```asp
% On choisis un nombre entre 1 et 100.
1 { nb(1..100) } 1.

% On écarte tout modèle dont le nombre choisis n'est pas multiple de 3.
:- nb(N) ; (N\3) != 0.
```

Premier constat, l'écriture d'une contrainte ressemble à celle d'une règle, à l'exception de la *tête*, qui est vide.
C'est exactement la description d'une contrainte dans la grammaire d'ASP: une règle sans tête.

Cela, logiquement, à un sens : la contrainte est une règle.
Hors, dans une règle, rappelez-vous : lorsque le *corps* est vrai, la *tête* est vraie.

Sauf que, dans le cas de la contrainte, la *tête* est vide : cela veux dire que si le *corps*
est vrai… rien ne peut être vrai !

C'est l'exact sens de la contrainte : si son *corps* est vrai, alors rien n'est vrai.
Il s'agit d'une contradiction fondamentale entre le fait que rien n'est vrai,
et que le *corps* (et probablement d'autres atomes du programme) est vrai.
Par conséquent, le modèle est faux, et ne sera pas considéré par le solveur.

Ici `(N\3) != 0` n'est vrai que si `N` n'est pas un multiple de 3 (N modulo 3, écrit `N\3` en ASP, renvois le reste de la division entière,
c'est-à-dire zéro quand le nombre divisé est multiple du quotient, ici 3).
Par conséquent, le *corps* de la contrainte est vrai lorsque nb(X) est vrai avec X un multiple de trois.
Le modèle est donc invalidé dans ce cas.
À l'inverse, lorsque X n'est pas un multiple de trois, le corps de la contrainte est faux, donc ladite contrainte n'invalide pas le modèle.

Ainsi, sur les 100 modèles précédemment générés, il n'en reste plus que 33:
les nombres entre 1 et 100 qui sont multiples de 3.

Un peu de gymnastique intellectuelle est nécessaire quand vous manipulez les contraintes :
elles expriment ce qui doit être faux, pas ce qui doit être vrai.


## Négation dichotomique
Il s'agit d'une forme de négation explicite sur un atome,
qui ressemblent, dans leurs effets, à des contraintes.

D'abord, considérons le programme suivant :

    {b;a}.

Il génère quatre ensembles-réponse : l'ensemble vide, a, b et ab.
Si nous ajoutons la règle suivante :

    a :- b.

Alors il n'y a plus que trois modèles : le modèle contenant uniquement b n'est pas possible, car a est une conséquence de b.
Jusqu'ici, rien de nouveau sous le soleil.

Maintenant, considérons ce programme :

    {b;a}.
    -a :- b.

La seule différence vient de l'atome a, préfixé d'un `-` dans la seconde règle.
Ce trait d'union est la marque explicite de la *négation dichotomique*.

Les answer-sets de ce modèle sont l'ensemble vide, a et b. Il n'y a pas a et b en même temps.

Pourquoi ?
Parce que `-a` signifie exactement *que l'atome a est faux*.
Or, lorsque l'on choisi à la fois a et b dans la première ligne, a et b sont vrais. Mais cela entre en conflit avec la seconde règle, qui stipule que *si b est vrai, alors a doit être faux*.

Une autre manière de l'écrire serais la suivante, indiquant que *a et b ne peuvent être vrais en même temps* :

    {b;a}.
    :- b ; a.

Bien qu'elles aient ici un effet identique, il existe entre ces deux écritures une différence logique.
Gardez-la donc en tête : parfois la négation dichotomique est plus simple ou lisible qu'une contrainte.



## Insatisfiabilité
*s'il n'y a pas de solution à un problème, c'est qu'il n'y a pas de problème*

Avec cette histoire de contraintes qui empêchent certains modèles d'exister,
on est en droit de se poser une question… Et si un problème n'est pas satisfiable,
c'est-à-dire qu'il n'existe pas de réponse ? Que se passe-t-il ?

Et bien, accrochez vous à vos ceinture, c'est tout à fait possible:

```asp
a.  % a est vrai
-a.  % a est faux (ici équivalent à `:- a.`)
```

Ceci est la contradiction la plus simple imaginable. C'est la quintessence même du ridicule,
on en viendrait à rire, autant que si les poules avaient des dents, en plus de leur bec !

De son côté, clingo réagit exactement comme il faut:

    clingo version 5.2.1
    Reading from program.lp
    Solving...
    UNSATISFIABLE

    Models       : 0
    Calls        : 1
    Time         : 5.189s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
    CPU Time     : 0.000s

Le problème est bien **insatisfiable**, autrement dit, il n'a aucun answer set, aucun modèle, aucun ensemble-réponse possible.

Un petit mot en passant : si vous avez un jour un problème, que vous arrivez à le modéliser en ASP,
et que vous obtenez une insatisfiabilité, c'est une preuve que votre problème n'est pas soluble (dans ce cas, est-ce encore un problème ?).

Ou alors que vous avez mal encodé votre problème :)


## Tokens
Petite partie théorique avant d'attaquer un nouveau morceau conceptuel.

Les tokens sont les *morceaux de texte*, les unités minimales qui peuvent être utilisées pour écrire.
C'est un concept théorique assez important, car il peut aider à comprendre mieux le langage dans son ensemble.

En ASP, il existe cinq types de tokens:

- les identifiants: par exemple `a`, `hello_world` ou `a_3_on_y_va`, **mais pas** `A`, `_`, `Arachide` ou `_case` (l'expression régulière est donc `[a-z][a-z0-9A-Z_]*`).
- les variables: un identifiant qui commence par une majuscule ou un underscore (exp. reg: `[A-Z_][a-z0-9A-Z_]*`).
- les nombres: seuls les nombres entiers sont gérés (expreg: `-?[0-9]+`).
- les textes: encadrés par des double-guillemets `"`, ils peuvent contenir n'importe quoi, sauf des double guillemets non précédés d'un antislash (sinon, ça termine le texte).
- les opérateurs: mathématiques (`+ - / * / \ ^ ..`) ou logiques (`; , :- : { }`)

Tout le langage ASP repose sur ces tokens.
Nous verrons qu'il existe un sur-ensemble du langage plus ou moins spécifique à clingo,
qui rentre dans la catégorie de la méta-programmation, mais c'est hors contexte pour le moment.

(C'est la méta-programmation qui nous permettra de *tuner* la recherche de la solution,
par exemple en définissant quels atomes doivent être affichés dans les résultats,
ou définir les valeurs de constantes)

<!-- TODO: un petit mot de la fin ? -->


## ∃ vs ∀
Vous connaissez certainement les deux opérateurs mathématiques suivant :
- ∃: *il existe*, c'est-à-dire *il y en a au moins un*
- ∀: *pour tout*, c'est-à-dire *tous les éléments considérés*

Par exemple *∃ jour de la semaine, je fais la grasse matinée* est vrai : pour moi c'est le dimanche.
Mais je connais des lève-tôt qui se lèvent tôt tous les jours. Pour eux, il faudrait plutôt dire
*∀ jour de la semaine, ils ne font pas la grasse matinée*.

En ASP, ces signes cabalistiques n'apparaissent pas explicitement, mais leur sémantique apparaît visiblement.
Le premier, *il existe*, nous l'avons déjà utilisé : il est implicite dans les *corps* des règles.

Ainsi, dans `a(X):- p(X)`, il est dit que a(X) est vrai si *il existe* un p(X).
C'est particulièrement visible avec la règle `a:- p(X)`.
Ici, il suffit qu'un `p(X)` soit vrai, quelque soit la valeur de X, pour que `a` soit vrai.

D'ailleurs, on pourrait écrire la même règle avec une variable muette pour que ce soit encore plus clair : `a:- p(_).`.

Maintenant que l'on comprend bien que le *il existe* est partout par défaut, attaquons
le *pour tout* avec un exemple complet :

```asp
% J'ai 3 copains dans ma classe
copain(1..3).
% Parfois certains ne viennent pas à la récré
{ en_recre(1..3) }.
% On joue au tarot quand on est tous les quatre
on_joue_au_tarot:- en_recre(C): copain(C).
```

Cet exemple génère 8 answer sets, dont un seul contient `on_joue_au_tarot`.

Ici, le corps de la dernière règle implémente
la condition *en_recre(C) doit être vrai __pour tout__ les copains C.*
Autrement dit, si il existe un copain C tel que `en_recre(C)` est faux, alors la condition est brisée,
et le corps de la règle est faux, et par conséquent, on ne joue pas au tarot.

Il est possible d'avoir plusieurs conditions à droite du `:`, et elles doivent être
séparées par une virgule `,` (et non un point-virgule).

<!-- TODO: un petit mot de la fin ? -->

## Exeeeeerciiiiiiice ! Garde contre et roi de trèfle
Ajouter au programme précédent la ou les règles nécessaire pour que l'atome `on_joue_au_ballon` soit vrai lorsque l'on ne joue pas au tarot
(donc, lorsque qu'un copain n'est pas là pour la récré).

### Aide
Si au bout de 10 minutes, vous:

- **n'avez rien essayé :** faites une pause plutôt qu'attendre que ça se passe : chantez les plus grands tubes de la compagnie créole, ça détends.
- **n'avez rien essayé, mais ya des nouvelles couleurs dans les couleurs de l'arc-en-ciel :** GG. Un indice : dichotomie. Ou négation.
- **avez trouvé comment faire, mais seulement dans le vide et avec des copains sphériques :** je suis content de voir que mon tuto est utile aux physiciens ! La solution est en fin de tuto.


## Erreurs et warnings
Une partie que je vois rarement dans les tutos pour un language, c'est celle dédiée aux erreurs.
L'intérêt, c'est de pousser les gens à ne pas paniquer en voyant un message d'erreur qui sort de leur code,
et d'apprendre à comprendre la méthodologie pour y répondre.

En vrai, la méthodologie elle est assez universelle : il faut lire, comprendre, réfléchir, corriger, réessayer.

### Unsafeness
En codant, il vous arrivera régulièrement de voir clingo lever une erreur du type :

```
test.lp:19:1-24: error: unsafe variables in:
  hadoken(Y):-[#inc_base];saiyan(X).
test.lp:19:9-10: note: 'Y' is unsafe
```

En clair, dans le fichier *test.lp*, ligne *19*, de la colonne *1* à *24*,
clingo n'arrive pas à décider de la valeur de la variable *Y*, utilisée dans le fichier *test.lp*, ligne *19*, de la colonne *9* à *10*.
C'est la notion même d'*unsafe* : une variable dont la valeur peut virtuellement être n'importe quoi.

Hors, vous vous en souvenez, on est sensé durant l'étape de grounding avoir la génération des atomes avec toutes les valeurs possibles.
Vous vous doutez que si le nombre de valeur possible sur un atome est infini, on a un problème.

Eh bien, c'est plus ou moins ce que détecte ici clingo : on ne sait pas quoi mettre en valeur de *Y*.

Dans ce cas précis, il s'agit juste d'une erreur de nom de variable :

```asp
hadoken(Y):- saiyan(X).  % effectivement, on se demande bien ce que peut être Y…
```

Il faut juste corriger pour que toute variable utilisée dans la tête soit définie dans le corps de la règle.


### Unsafeness, deuxième tournée
Retrouvons l'erreur, légèrement changée :

```asp
test.lp:19:1-36: error: unsafe variables in:
  hadoken(Y):-[#inc_base];saiyan(X,Y):gandalf(X).
test.lp:19:9-10: note: 'Y' is unsafe
```

Dans ce cas précis, on avait le code suivant :

```asp
hadoken(Y):- saiyan(X,Y): gandalf(X).
```
Autrement dit: on a hadoken Y s'il existe un saiyan X Y pour tout gandalf X. Ne cherchez pas la logique dans la sémantique, mais plutôt dans le lexique.
On définit bien X: il s'agit d'une valeur donnée par l'atome gandalf. Mais Y ?
Eh bien, imaginons que `saiyan(X,Y)` soit définit tel que X est une valeur donnée par gandalf/1, et Y une valeur donnée par dumbledore/1.
Dans ce cas, il nous suffit de rajouter une définition pour Y:

```asp
hadoken(Y):- saiyan(X,Y): gandalf(X) ; dumbledore(Y).
```

Et voilà, l'erreur a disparue.
Maintenant, le sens pourrait être différent: on pourrait vouloir hadoken Y s'il existe un saiyan X Y pour tout gandalf X **et pour tout dumbledore de Y**.
Dans ce cas, on utilise la virgule pour include dumbledore dans la condition *pour tout* :

```asp
hadoken(Y):- saiyan(X,Y): gandalf(X), dumbledore(Y).
```

L'unsafeness arrive également quand dans une condition *pour tout* des variables à gauche du `:` ne sont pas définies, à droite du `:` (premier cas) ou dans le contexte de la règle (second cas).


### Syntax error
Celle-là sont en général assez simple à résoudre : il s'agit d'une mésutilisation de la grammaire du langage.

Souvent, lorsque vous avez une telle erreur, c'est que vous avez oublié un point, une parenthèse,…

Comme clingo vous donne l'endroit où est arrivé un *token* inattendu (comme un identifiant à la place d'un point par exemple),
il est assez simple de voir d'où viens l'erreur.
Petit détail : clingo vous donne la localisation du *token* inattendu : cela veut dire que si l'erreur est levée à cause d'un point qui manque,
c'est le token suivant qui sera ciblé.

Donc le code suivant lève bien une erreur :

```asp
atome(avec,arguments,mais,sans,point)
autre_atome(normal,celui,la).
```

Mais clingo vous dira que l'erreur provient de la seconde ligne. C'est normal : de son point de vue,
c'est `autre_atome` qui est en faute, puisqu'il s'agit d'un identifiant qui se trouve près un atome complet,
ce qui n'est pas *attendu* d'après la grammaire du langage ASP.

Ce détail est très important, et quand on débute en informatique, on a tendance à regarder uniquement la ligne d'où vient l'erreur.


## Exeeeeerciiiiiiice ! Yodel et papier crépon
Je ne vous le cacherais pas : cet exercice est un poil plus complexe que les précédents, mais ne vous en faites pas, vous y arriverez tout pareil.

Voici l'énoncé : on cherche des ensembles de personnes partageant les même goûts,
sachant que l'on sait qui aime quoi via les atomes `aime/2`, tel que `aime("Gérard","Joueur du Grenier")`
signifie que Gérard aime l'émission du [Joueur du Grenier](https://fr.wikipedia.org/wiki/Joueur%20du%20Grenier).

Assez simplement, deux personnes partagent les même goûts si elles aiment une chose en commun.
Il existe au moins deux manières de faire ; voici donc quelques phrases qui pourraient vous aider à trouver
les différentes manières d'attaquer le problème.

- *Il y a au moins deux personnes, au moins un sujet, et tous les atomes aime/2 nécessaires sont vrais*
- *Il y a au moins deux personnes, au moins un sujet, et il n'existe pas de paire personne-sujet tel que aime/2 n'existe pas*
- *Les personnes choisies aiment les sujets choisis, et les sujets choisis sont aimés par les personnes choisies.*


### Les données
```asp
aime("Gérard",("Joueur du Grenier";"Les pois cassés")).
aime("Julie",("Les pois cassés";"Star Wars 9: les siths fantôme contre-retournent l'espoir")).
aime("Marlène",("Les chansons des années 20";"Symballium volume 4";"les roses vertes")).
aime("Michel",("La grande musique (dans le sens de la longueur)";"Star Wars 9: les siths fantôme contre-retournent l'espoir")).
aime("Dominique",("La grande musique (dans le sens de la longueur)";"les roses vertes";"Les poids cassés";"Symballium volume 4")).
```

Avec ces données, vous devriez obtenir 6 modèles. Si vous en obtenez plus, il est possible que certains
des modèles soient des sous-ensembles d'autres modèles. C'est l'effet de bord d'une des deux solutions.


### Aide
Si au bout de 30 minutes, vous:

- **n'avez rien essayé :** bon, au risque de paraître un tantinet habité d'une quelconque passion à propos d'une soupe où nagerait des atomes d'avocats (au sens philosophique, pas physique), j'aimerais vous raconter une petite anecdote, que je connais d'expérience, et qui est assez représentative de l'expérience générale des enseignants dans mon domaine. Il se trouve que, lorsqu'on enseigne, on s'aperçoit assez vite que pas mal d'étudiants (et il se trouve qu'il s'agit majoritairement de filles, moins souvent des gars ; rapport à l'éducation ?) essayent à peine, ou lorsqu'ils essayent, c'est avec un mélange de timidité et de stress ; si bien que, au bout de longues minutes à s'imaginer être incompétents, ils finissent par appeler l'enseignant pour de l'aide. Enseignant qui ne voit qu'un écran blanc, et n'a comme unique information *j'y arrive pas*. Difficile de faire quoique ce soit dans ce contexte, et même impossible si yavais soupe d'avocat à la cantine. Le truc, c'est que ces étudiants ne se lancent pas, craignent l'idée de ne pas réussir du premier coups (comme si c'était possible, ou même souhaitable). Je sais que c'est un problème très commun en info (ça doit arriver ailleurs, certainement), mais je n'ai aucune espèce de piste pour résoudre le problème, à part travailler, en amont, au niveau de l'éducation elle-même. La conséquence de ça, je pense, c'est que ces étudiants ne collectent aucune expérience qui sera plus tard nécessaire à faire un boulot en info (ou un boulot tout courts). Certains arrivent au bout de plusieurs années d'études, et sont toujours incapable de lire ou écrire un quelconque morceau de code. Je n'ose imaginer ce que ça donne après dans un contexte professionnel. Bref, évitez la soupe à l'avocat.
- **n'avez rien essayé, mais c'est parce que votre poisson rouge est mort, votre grand-mère s'est remise à l'haltérophilie, votre ordinateur fait des mises à jour, et il est déjà 24h64 à hawaï :** je comprend, ça doit être dur. Un indice : l'ASP c'est tellement haut niveau, il suffit souvent de traduire les phrases pour avoir un résultat.
- **avez trouvé 18 manières différentes de résoudre le problème, mais toutes nécessitent un microscope électronique à balayage et à pile, ou une fusée voyageant à au moins 0.6c :** vous avez peut-être mal compris l'énoncé. Les solutions sont toujours en bas de page, et vous noterez qu'elles ne nécessitent aucun appareillage sophistiqué.



# En pratique !
Maintenant que l'on a les bases, nous allons (enfin !) pouvoir
attaquer de vrais problèmes.

Je suis certain que depuis le temps, vous vous êtes demandés
si tout ceci n'était pas une vaste conspiration pour vous faire perdre votre temps.
Mais ne vous inquiétez pas : il n'y a nul conspiration.

Ici, il ne s'agit pas d'exercice à proprement parler, dans le sens où le but est de lire et comprendre un code existant.
Néanmoins, la définition du problème sera donnée en amont, et par conséquent, vous permet d'essayer de votre côté
avant de regarder le code tout fait.

Je vous conseille évidemment de faire les choses ainsi.

Notez également qu'une *directive de méta-programmation* sera utilisée pour éviter de polluer trop la sortie des solutions : `#show`.
Ne vous inquiétez pas trop à ce propos, il s'agit juste de choisir quels atomes sont affichés en sortie.
Ignorez-le dans un premier temps, triturez le un peu pour comprendre après (le premier exemple s'y prête bien),
et éventuellement allez lire [la partie qui y est consacrée](#show).


## Du bruit dans la cuisine
*Un petit exercice qui me vaudra des lettres de menace de la part de mes amis acousticiens.*

En considérant une maison, composée de diverses pièces (genre, la cuisine, le salon, le placard à balai,…),
dont l'une est la source d'un bruit d'un certain niveau (d'une certaine force, dirons nous, afin d'agacer les physiciens).

Question : quelle est le niveau sonore enregistré dans les autres pièces ?

Approximation : disons qu'un niveau sonore est une valeur qui va de 1 à 10,
pour 1 étant *à peine audible* et 10 étant *j'ai mal aux tympans*, et que le niveau baisse de 1 pour chaque pièce traversée.
(pour le dire autrement : pas d'échelle logarithmique, pas de calculs pour les phénomènes de réverbérations/amortissement, que sais-je encore)

Intuitivement, le son ne se propage d'une salle à une autre que si elles sont connectées,
et le niveau sonore enregistré (ce qui nous intéresse) est égal au niveau maximal dans la salle.

### mézon
Voici une manière d'encoder le plan de la maison :

```asp
% connected rooms
next_room(0,9). % la salle 0 est à côté de la salle 9
next_room(4,(3;5)).  % la salle 4, à côté des salles 3 et 5
next_room(6,(3;13;5)).  % et caetera
next_room(7,(0;1;2;3;8;12;13)).
next_room(8,(9;11)).
next_room(10,(9;11)).
next_room(11,(10;12)).
```

Et maintenant, on dit qu'il y a un son de niveau 10 dans la salle 4:
```asp
sound(4,10).
```

Logiquement, puisque le niveau sonore ne peut que baisser, la salle 4 possède déjà son niveau sonore enregistré : 10.
On notera que, par définition, une salle accessible depuis la 4 aura un niveau sonore de 9.

Vous avez largement ce qu'il faut pour décider de votre approche !


### Calcul de solutions
Voici une solution possible

```asp
% le lien est commutatif : si A est à côté de B, alors B est à côté de A.
next_room(X,Y):- next_room(Y,X).

% Transmission du niveau sonore, avec un offset de -1.
sound(X,Level-1):- sound(Y,Level) ; next_room(X,Y) ; Level >= 0.

% On ne considère que le niveau sonore maximal.
max_sound(X,L):- sound(X,L) ; not sound(X,L2): L2 > L, sound(X,L2).

% N'afficher que les niveaux sonores enregistrés.
#show.
#show max_sound/2.
```



## Placement de table, première approche
Lors d'une fête de famille, ils y a deux problèmes majeurs :

- qui finit les frites ?
- qui s'assoie où à table ?

C'est bien entendu le second qui nous intéresse ici.

### Spécification du problème
L'idée est la suivante : nous avons un ensemble de places numérotées,
et des relations entre elles. Par exemple : la place 2 est à côté des places 1 et 3, et en face de la place 9.

Nous avons également des personnes, qui doivent toutes être placée sur une place exactement.

Maintenant, il y a des contraintes. Par exemple :

- Justin ne peut pas être à côté ou en face de Karine, ils ne se supportent pas.
- Mettre Cunégonde et Roger à côté est en revanche conseillé : ensembles ils font rire leur voisin avec leurs histoires de championnat de scuba-curling.
- Mamie doit être à côté de la cheminée, mais pas Gérard, qui a vite trop chaud.
- Si Pépé est à côté de Jeanine, alors Xavier doit être de l'autre côté de Jeanine.
- Yolande veut être à la place la plus éloignée de la cuisine, pour éviter d'avoir à y aller.
- Si Micheline peut voir Dominique, elle lui fera des remarques bruyantes et désagréables sur sa frange mauve : donc non.

Bref, le joyeux bordel typique du placement de table d'une réunion de famille.
Eh bien, rassurez-vous : ce calvaire est fini, vous pouvez annoncer à votre famille que désormais c'est vous qui vous en occupez !
Et ça ne vous prendra pas bien longtemps pour tout encoder parfaitement, et placer les étiquettes indiquant les positionnement des gens.
Il ne reste donc plus qu'à vous faire mousser pour *ce placement de table par-fait !*

### Objectif
Avoir pour chaque personne une place qui lui convienne.

Avoir plusieurs modèles/ensembles réponse, chacun décrivant un positionnement possible.


### Pourquoi une première approche
Il est sous-entendu qu'une seconde approche se fera, plus tard.
Effectivement, cette première approche est naïve : elle considère qu'il existe une solution qui satisfasse toutes les contraintes.
Si vous avez une famille avec beaucoup de contraintes, il est possible que le problème soit insatisfiable,
et par conséquent, certaines contraintes doivent être retirées.

Il existe une solution élégante à ce problème, grâce aux directives de méta-programmation, et plus précisément les *optimisations*,
que nous verrons plus tard.

C'est donc dans la deuxième volée d'applications que nous verrons une approche plus maligne qui nous permettra de gérer les familles trop compliquées.
Cela dit, même si votre famille est compliquée, il est possible qu'une solution existe : alors tentez malgré tout, vous pourriez être surpris.



## Résoudre une énigme du livre jaune des devinettes
Le livre jaune des devinettes est un texte qui se trouve dans le jeu Skyrim,
dans lequel on trouve quelques énigmes écrites. L'une d'entre elle nous intéresse tout particulièrement,
car elle tombe pile dans le cadre de la logique. En voici l'énoncé :

> Un Bosmer a été tué.
> L'Altomer affirme que le Dummer est coupable.
> Le Dummer accuse le Khajiit.
> L'Orque jure qu'il n'a pas tué le Bosmer.
> Le Khajiit dit que le Dummer ment.
> Si un seul de ces messieurs dit la vérité, qui a tué le Bosmer ?

Les noms propres sont propres à l'univers du jeu The Elder Scrolls, et n'a aucun impact sur la résolution.
Si cela vous gêne, remplacez Bosmer, Altomer, Dummer, Orque et Khajiit par Gérard, Gontran, Michel, Eugène et Siméon.


### Réponse
Le code ASP est étonnement proche de l'énoncé.
Notez que les deux premières expressions sont données implicitement dans le problème. Notre ordinateur n'étant pas une intelligence forte,
nous devons même si cela tombe sous le sens lui donner explicitement l'informations qu'il y a un coupable, et qu'il s'agit de l'un des quatre suspect.

```asp
% Un des quatre suspect est coupable.
ppl(altomer;dummer;khajiit;orque).
1{guilty(X): ppl(X)}1.

% L'Altomer affirme que le Dummer est coupable.
right(altomer):- guilty(dummer).
% Le Dummer accuse le Khajiit.
right(dummer):- guilty(khajiit).
% L'Orque jure qu'il n'a pas tué le Bosmer.
right(orque):- not guilty(orque).
% Le Khajiit dit que le Dummer ment.
right(khajiit):- not guilty(khajiit).
% Un seul de ces messieurs dit la vérité.
1{right(X): ppl(X)}1.
```

L'unique answer set reçu est `ppl(altomer) ppl(dummer) ppl(khajiit) ppl(orque) guilty(orque) right(khajiit)`, qui contient notamment `guilty(orque)`.
C'est bien, d'après le livre jaune des devinettes, la réponse attendue !

Grâce à ce code ASP, on peut jouer au détective : que se passe-t-il si 1 ou 2 personnes disent la vérité ? Et si une complicité entre deux suspects est possible ?
Dans ces cas là, notez la place particulière de l'Orque.





# Métaprogrammation
*Où l'on apprend que bien des choses sont possibles avec juste un petit zest de méta(l)*

Métaprogrammation est un mot qui peut faire peur, un peu comme *nombre complexe* en maths, ou *staphilococus* en cours de phylogénie.
Mais en vrai, ça va.

Clingo (gringo) est capable de comprendre un sur-ensemble de l'ASP qui relève de la méta programmation.
Autrement dit, il existe des expressions valides qui ne sont pas de l'ASP, mais qui permettent de manipuler
le grounding ou le solving du programme (c'est donc [méta](https://fr.wikipedia.org/wiki/M%C3%A9ta%20(pr%C3%A9fixe))).

Ces expressions ce nomment *directives de métaprogrammation*, et commencent systématiquement par un `#` (elles sont donc faciles à reconnaître).

Nous allons ici voir les plus utiles. Pour plus d'exhaustivité,
je vous renvoie [au manuel de clingo](http://sourceforge.net/projects/potassco/files/guide/).


## #show
Il s'agit probablement de la directive la plus utilisée : il s'agit de déterminer
quels atomes seront affichés dans la sortie de clingo.

En effet, pour chaque answer set, clingo donne la liste complète des atomes
vrais. Dans certains cas, notamment quand vous avez beaucoup de données et d'atomes intermédiaires,
seuls quelques uns vous intéressent.

Par exemple, si vous codez un solveur de sudoku, les données (les cases déjà remplies)
ne changent pas, sont constantes d'un answer set à l'autre : vous ne voulez pas les afficher.

C'est là que `#show` intervient.

```asp
a(1;2;3).
b(X):- a(X).
#show b/1.
```

En runnant ce programme, avec ou sans la dernière ligne,
vous allez avoir *exactement* 1 modèle/answer set, contenant 3 ou 6 atomes selon les cas.

Pour être plus rigoureux, dans les deux cas les atomes vérifiés dans le modèle sont strictement identiques,
c'est juste qu'avec la dernière ligne, seuls 3 sont affichés (ceux ayant `b` comme prédicat).
**Show change les atomes affichés, pas les answer sets.**

Notez la manière dont on renseigne *l'ensemble des atomes de prédicat `b`*: en utilisant une notation très courante dans le monde de la programmation logique: `<prédicat>/<arité>`.
Si vous remplacez le 1 par un 2, clingo n'affichera rien : il va en effet afficher uniquement les atomes de prédicat `b` avec deux arguments, c'est-à-dire, dans ce cas précis, aucun.

### Un truc rigolo
*Regardez, ce programme fait bugger clingo ! Il lui fait afficher 3 fois la même réponse ! Alors que normalement c'est pas possible, on l'a vu dans une section précédente !*

```asp
a(1;2;3).
b:- a(X).
#show b/0.
```

Bon, vu que vous avez lu le paragraphe sur `#show`, vous ne vous êtes pas fait avoir :
ce n'est pas trois answer set équivalents, mais 3 différents qui sont affichés pareil.


### Le côté obscur de #show
Le programme suivant affiche 4 atomes, et aucun d'entre eux ne fait réellement partis du modèle trouvé par le solveur.

```asp
b(1).
#show b.
#show 23.
#show p(X): b(X).
```

Nous voyons ici trois usages différents de show.
Le premier et le second sont des moyens d'afficher des données, y comprit des nombres.

Le troisième montre qu'il est possible de faire quelques opérations logiques sur les règles à montrer.
Cela peut servir pour filtrer précisément les atomes à afficher, ou pour renommer les atomes
(ici, on renomme `b/1` en `p/1`).

Notez bien que ces usages de *show* sont *génératifs* : ils ajoutent des atomes dans la réponse,
sans les ajouter dans le solving lui-même (essayez en ajoutant `c(X):- p(X).`, vous verrez que c/1 n'appartient pas à l'answer set, car aucun p/1 ne s'y trouve).

Notez également que, contrairement à l'usage précédent, le *show* ici n'a pas empêché les autres atomes du programme d'être affichés, car `b(1)` est bien affiché par clingo.
C'est parce que tous les shows du programmes sont *génératifs*. Rajoutez en un seul qui ne le soit pas, et vous perdez `b(1)`.

### Le #show impératif
Il existe une dernière forme pour cette directive : `#show.`.
Elle se traduit par *n'affique strictement que ce qui est demandé*.

Par exemple, si tous les shows de mon programme sont génératifs (cf section précédente),
comment faire pour n'afficher que ceux-là, et pas le reste du programme ?

```asp
a.
#show 23.
```

Ce programme va afficher dans l'unique modèle les atomes *a* et *23*.
Maintenant, si j'ajoute `#show.` quelque part…

```asp
a.
#show.  % par exemple, ici
#show 23.
```

Paf ! Seul *23* est affiché. Pourquoi ? Parce que *a* n'a pas été explicitement rattaché à un show,
et n'est donc pas affichable.

En général, les directives `#show` se trouvent en fin de fichier (du point de vue de l'humain,
c'est la dernière chose qui est faite), et le premier *show* est généralement `#show.`.
C'est une habitude qu'on retrouve dans beaucoup de codes ASP.

Cependant, ils se retrouvent parfois au tout début, pour que le lecteur
sache tout de suite quelles sont les outputs. Malin !


## #const
Comme C utilise `#define` et `const`, clingo utilise un mélange des deux : `#const`.
Là s'arrête le parallèle, et commence un exemple :

```asp
#const ma_constante_avec_un_nom_a_rallonge = 42.
#const m_constnte_sns_l_lettre_ = "a".

a(m_constnte_sns_l_lettre_).
a(ma_constante_sans_la_lettre_b).
p(X):- X=ma_constante_avec_un_nom_a_rallonge.
#show ma_constante_avec_un_nom_a_rallonge.
```

Nous avons ici deux constantes, nommées `ma_constante_avec_un_nom_a_rallonge`
et `m_constnte_sns_l_lettre_`, associées aux valeurs 42 et "a", respectivement.

Le `#const` se comporte comme le `#define` du C: lors du *grounding*,
toute occurence du nom de la constante sera remplacée par sa valeur.

Et tout comme le `#define` en C, il peut être réécrit lors de l'appel au compilateur.
Dans notre cas, lors de l'appel à clingo.

Ainsi, si vous voulez définir la valeur d'une constante lors du lancement du programme,
il suffit d'utiliser l'option `-c` : `clingo -c ma_constante_avec_un_nom_a_rallonge=23`.
Il s'agit donc d'un excellent moyen de proposer une personalisation d'un programme
sans avoir à tripoter le code.

Enfin, notez que tout comme le préprocesseur du C, clingo est malin :

```asp
#const cst = b.
cst(cst).
```

Ce code génère un answer set d'un atome qui est… `cst(b)`,
car __*#const* agit sur les valeurs, pas les prédicats.__


## pause détente
Quel est le style de musique préféré des programmeurs lisp ?

Le heavy-méta.


## #minimize et #maximize
Le nerf de la guerre dans bien des problèmes dits *d'optimisation*.

Les answer sets trouvés par le solveur ne sont pas toujours égaux :
souvent, l'objectif est de maximiser ou minimizer un score,
et cela permet de trier les bonnes et les mauvaises solutions.

Par exemple, si vous créez un solveur de puzzle, vous allez vouloir préférer
les solutions qui utilisent le moins de ressources (nombre de coups, nombre de pièces,
nombre de je-sais-pas-quoi-que-le-puzzle-utilise-et-qu'on-veut-utiliser-le-moins-ou-le-plus-possible,…).

Dans un autre registre, c'est ce qui nous permettra, dans les prochains exemples,
de trouver le *meilleur* PC selon des contraintes diverses.

En général, à partir du moment où vous cherchez *le plus bidule* ou *le moins machin*,
vous avez besoin d'une minimisation ou maximisation.
(parfois ce ne sera pas nécessaire, mais gardez l'idée à l'esprit)


### Considérations techniques
En soit, ça ne change pas grand chose sur le solving, puisqu'en théorie,
il suffit de générer toutes les réponses, puis les trier selon leur score.

L'inconvénient, c'est qu'il faut (1) énumérer tous les réponses, ce qui n'est pas forcément pratique
(essayez donc de générer et sauvegarder l'ensemble des grilles de sudoku pour voir),
et (2), trouver le maximum là-dedans *a posteriori*, c'est-à-dire sans que l'heuristique du solveur n'ait joué de rôle.

Hors, et c'est bien là tout l'intérêt d'une heuristique faite par des experts :
si on donnait la mesure du score à l'heuristique, elle ne se contenterait pas d'énumérer les réponses possibles et de les triers par score :
elle s'abstiendrait de générer celles qui sont moins bonnes que celles déjà générées (on parle *d'élaguage de l'espace de recherche*).

En d'autre terme, donner à l'heuristique nos préférences en matière de modèle lui permet d'élaguer l'espace de recherche
pour aller plus vite, et se diriger petit à petit vers l'une des meilleure réponse, le *modèle optimal*.


### Syntaxe
La syntaxe est un poil bizarre au début, mais on s'y fait bien.

```asp
1 { nb(1..100) } 1.  % un modèle == un entier
#maximize{N:nb(N)}.  % maximiser l'entier choisi
```

Ici, c'est la deuxième ligne qui fait le travail d'optimisation : on dit à clingo de maximiser N,
pour N le nombre choisi en ligne 1.

Il y a beaucoup de subtilités avec cette syntaxe, essayez par exemple de changer
la borne supérieure de la disjonction par un 2, ou par rien.

Notez aussi que, pour minimiser, il suffit de remplacer `maximize` par `minimize`.


### Priorité
Parfois, il y a plusieurs paramètres à minimiser/maximiser.

```asp
1 { nb(1..100) } 1.  % un modèle == un entier
#minimize{N@2:nb(N)}.  % minimiser l'entier choisi (priorité 2)
#maximize{N@1:nb(N)}.  % maximiser l'entier choisi (priorité 1)
```

### Considérations générales
Les optimisations, qu'elles soient de maximisation ou minimisation, sont des composantes importantes de l'heuristique :
non seulement elles permettent d'élaguer l'espace de recherche, mais elles permettent de réellement encoder certains problèmes
sans avoir à modéliser les relations entre modèles.

Imaginez devoir générer le meilleur remplissage de sac-à-dos sans optimisation : même avec un petit sac,
il existe une très grande quantité de manière de ranger des objets dans un sac,
et surtout, beaucoup sont équivalentes.
Sans optimisations, vous allez vous retrouver avec (1) un très grand nombre de modèles qui (2) sont inintéressants pour 99% d'entre eux.

Avec une optimisation, vous n'avez qu'à compter la place restante dans le sac, et minimiser ce nombre :
le solver s'occupe seul de ne pas polluer la sortie : le dernier modèle trouvé par le solveur est à tout instant le meilleur qu'il ait trouvé.
Cela veux même dire que vous pouvez l'arrêter en cours de route, lorsque les modèles qu'il propose sont suffisamment bons.


## #min et #max
Utiles.
## #count
Utile.
## #project
Un détail avec de l'importance.
## #program
Des fichiers dans des fichiers.





# Interface avec Python
*Où l'on apprend comment interfacer un langage puissant avec un langage puissant pour faire des trucs vachement puissants*

ASP s'interface nativement avec Python et Lua. Je ne traite que de Python ici,
mais les principes sont exactement les mêmes avec Lua : seule la syntaxe change.

Si vous ne connaissez pas python, ignorez cette section. Il me faudrait 5000 lignes supplémentaires pour expliquer les concepts que j'utilise ici,
et du coups ce tuto deviendrait un énième [tuto pour python](https://python.developpez.com/cours/TutoSwinnen/).
Si c'est juste les concepts de POO qui vous manquent, allez voir [sametmax](http://sametmax.com/le-guide-ultime-et-definitif-sur-la-programmation-orientee-objet-en-python-a-lusage-des-debutants-qui-sont-rassures-par-les-textes-detailles-qui-prennent-le-temps-de-tout-expliquer-partie-1/). Si vous connaissez déjà python et que vous voulez progresser, allez voir [sametmax](http://sametmax.com/cours-et-tutos/).

## Embedding dans Python
Plutôt qu'appeler clingo pour tous nos cas de tests,
et vérifier à la main si ils fonctionnent correctement,
ou juste si on a besoin d'appeler clingo plusieurs fois avec des traitements des résultats,
il est possible de le faire depuis Python.


### API officielle
Il existe un module officiel, qui est dans les sources du logiciel et que vous pouvez installer avec un `python setup.py install` standard après compilation de clingo.

Je n'utilise pas cette API en règle générale, puisqu'il faut que le client compile clingo.


### Autres API
Je vous recommande pour démarrer [clyngor](https://github.com/aluriak/clyngor).
C'est un module python on ne peux plus standard, disponible sur pypi,
et qui ne nécessite qu'une chose: que le binaire clingo soit dans votre $PATH.

Et normalement, c'est déjà fait :)

Une alternative est [pyasp](https://github.com/sthiele/pyasp).
Néanmoins, ce package et ne supporte pas clingo *seul*,
mais plutôt gringo et clasp comme deux binaires
séparés appelés séquentiellement.
Hors, dans les nouvelles versions du solveur, seul clingo est distribué.
Pyasp n'est donc (pour le moment) pas une alternative viable pour utiliser
les versions les plus récentes.




## Extending avec Python: Propagateurs
Vous avez déjà étendu Python avec du C pour gagner un peu en performances ?
Eh bien, de la même manière, on peut mettre du Python (ou du Lua) dans ASP
pour profiter, pendant le solving même, de la puissance d'un langage impératif.
C'est ce qu'on nomme embedding, ou extending selon le point de vue.
Ici, nous allons voir comment embed du Python dans ASP, ou, c'est équivalent, extend ASP avec Python.

Les propagateurs sont des objets assez connus dans le monde du solving.
Il s'agit plus ou moins d'un plugin qui va pouvoir suivre et modifier le déroulement de l'heuristique.
Pour être encore plus pédagogue : un propagateur permet d'écrire des contraintes en python plutôt qu'en ASP.

Avec Python et un peu de connaissance sur clingo, il est possible d'écrire un propagateur pouvant,
par exemple, changer la véracité de certains atomes en fonction de celle d'autres atomes.

Notez que l'API officielle de clingo est nécessaire ici. Si vous ne l'avez pas, vous ne pourrez pas exécuter les exemples
(mais vous pourrez les comprendre quand même ; notre cerveau est bien pratique parfois).


### Sous le capot de clingo
Clingo, en interne, ne s'amuse pas à manipuler les atomes comme `p(5)` ou `q(a,b,c(p(a,b("e"),d)))`
sous la forme de chaîne de caractères, ou d'objets plus complexes.

La raison est simple : c'est inefficace, d'autant que clingo se fiche de savoir que tel atome a tel predicat et tel arguments :
il s'intéresse uniquement aux propagations qu'il peut faire selon les règles qu'on lui a fournis.

Par exemple, `p(5):- p(4).` devient pour clingo quelque chose comme `12 :- 45`. Là, j'ai choisi les entiers au hasard,
mais clingo, d'après ce que j'ai vu, les numérote à partir de 1, dans l'ordre où il les rencontre.
C'est donc, de notre point de vue d'utilisateur extérieur, aléatoire.

Donc, clingo manipule des entiers, qui sont appelés officiellement des *solver literals*, ou litéraux du solver.
Ces litéraux du solveur ne changent pas durant tout le solving, et ce sont les éléments de base qu'un propagateur va manipuler.
Le solveur associe à ces littéraux une des trois valeurs de vérité suivante : vrai, faux, non valide.
Au tout départ, tous les atomes sont non valides, sauf ceux dont vous indiquez la véracité par défaut, par exemple avec l'expression `a.`: l'atome `a` ne sera jamais faux.
Puis, en respectant les règles comme `p(X):- q(X) ; r(X).`, le solveur va pas à pas changer les valeurs de vérité des atomes.
Si à un moment il s'aperçoit que ce qu'il fait est impossible, il *backtrack*, c'est-à-dire qu'il va revenir en arrière, pour essayer d'autres combinaisons.

Et si à un moment tous les atomes ont une valeur de vérité vraie ou fausse, et qu'aucune contrainte n'est violée, alors le solveur sait qu'il s'agit d'un ensemble réponse :
il affiche alors tous les atomes ayant une valeur de vérité vraie.

Un propagateur va pouvoir agir à différents moments : au début, lorsque le solveur découvre les atomes, lorsque le solveur propose une valeur de vérité pour un atome (on dit alors qu'il *propage*), lorsqu'il *backtrack*, ou lorsqu'il a dans les mains un answer-set valide.

### Les 4 cavaliers
Un propagateur, en python, est une classe présentant au moins une de ces 4 méthodes :

- `init`: appelée une seule fois, en première ; c'est là qu'on prend connaissance des littéraux du solveur choisis pour chaque atome
- `propagate`: appelée chaque fois que l'heuristique va donner une valeur de vérité à un littéral (dire qu'un atome est vrai ou faux)
- `undo`: appelée chaque fois que l'heuristique va retirer une valeur de vérité à un littéral
- `check`: appelée chaque fois que l'heuristique vérifie le modèle qu'elle possède

#### Vérification de modèle et vérité des litéraux
Comme nous avons vu au début, un atome est soit vrai, soit faux.

Ceci est faux : un atome peut également être dans un état indéterminé. Si nous ne l'avons jamais vu,
c'est parce que cet état n'est possible que lorsque l'heuristique cherche pour un modèle valide.
Pendant cette recherche, l'heuristique va donner des valeurs de vérité (vrai ou faux) aux atomes,
chacun à leur tour, explorant les différentes possibilités.

Lorsque tous les atomes ont une valeur de vérité (on parle alors d'assignement total, en opposition à un assignement partiel
où ne sont assignés à une valeur de vérité qu'une partie des atomes),
il faut décider si le modèle, c'est-à-dire si les valeurs de vérité (ou assignation) est valide.

C'est le dernier moment pour les contraintes pour montrer que l'assignement total entre en conflit avec une contrainte, prouvant que le modèle n'est pas valide,
et donc qu'il n'a pas a être écrit en sortie de programme.

### Exemple de propagateur : dot propagator
Celui-ci est très simple : il s'agit d'afficher un `.` pour chaque propagation du solveur, et d'en retirer un pour chaque *back-propagation* (ou *undo*).
Cela résulte en une ligne de point qui progresse et régresse au fil de l'exploration du solveur.

Ce propagateur est présent dans [le code source de clingo](https://github.com/potassco/clingo/tree/master/examples/clingo/dot-propagator) en figure d'exemple,
et permet de toucher du doigt l'intérêt des propagateurs.
Suis la version annotée des sources.

```python
% Là on est dans le code ASP
#script (python)
# et paf, on est en python maintenant !

from time import sleep  # pour donner une dimension humaine au programme

# La classe qui contient les méthodes. Notez qu'il n'y a évidemment aucune contrainte sur le nom,
# et surtout que la classe n'hérite de rien. Duck Typing FTW.
class Propagator:

    # Première méthode : init (sans les `__`, car il s'agit bien de l'init du propagateur, pas de l'objet)
    def init(self, init):
        # init: un objet qui va nous donner des infos sur le solving
        for atom in init.symbolic_atoms:  # pour chacun des atomes du programme
            init.add_watch(init.solver_literal(atom.literal))  # on le surveille

    def propagate(self, ctl, changes):
        # ctl: c'est le contrôleur du solving ; un objet qui mériterait une section à lui tout seul.
        # changes: la liste des littéraux qui ont eu une assignation ; c'est eux qui nous intéressent.
        for _ in changes:  # la valeur exacte ne nous intéresse pas
            print('.', flush=True, end='')  # afficher un `.` sans passer à la ligne
            sleep(0.1)  # sans ça, vous n'allez rien voir, le programme semblera immédiat
        # À essayer de votre côté: afficher changes à la place des points. Ça permet de voir en quoi consiste le backtrack.

    def undo(self, solver_id, assign, undo):
        # undo contient la liste des littéraux dont l'assignation est annulée.
        # on va donc enlever un '.' pour chacune de ces assignation.
        for _ in undo:  # la valeur exacte ne nous intéresse pas
            print('\b \b', flush=True, end='')  # revenir en arrière, afficher un espace, revenir en arrière
            sleep(0.1)  # sans ça, vous n'allez rien voir, le programme semblera immédiat

# notez que la function main est une convention de l'API de clingo :
#  si elle existe, elle reçoit le contrôleur du solveur, et nous
#  permet donc de contrôler le solving.
def main(prg):
    # prg: un contrôleur du solveur. C'est lui qu'on va utiliser pour faire ce qu'on veut
    # on enregistre une instance de notre propagateur
    prg.register_propagator(Propagator())
    # on ground le programme 'base', qui est le programme par défaut
    prg.ground([("base", [])])
    # on lance le solving
    prg.solve()
    print()  # on écrit une ligne vide après les '.'

#end.
```

Vous pouvez tester ce code avec n'importe quel programme ASP.
Le [pigeon-hole problem](https://github.com/potassco/clingo/blob/master/examples/clingo/dot-propagator/test.lp) est un bon exemple
(pas un hasard qu'il soit fourni avec le propagateur ;\) ) car il génère beaucoup de backtracks (de retours en arrière dans la recherche).

Le résultat est, vous vous en doutez, diablement rigolo :

TODO: un gif de la sortie du dot propagator


### Exemple de propagateur : color propagator
Dans la série des visualisations rigolotes, je vous propose… le *color propagator* !

Le principe : afficher les atomes disponibles, et les mettre en couleur
en fonction de leur valeur d'assignation.

Compliqué ? Non, pas tant que ça :

```python
#script (python)

# de nombreux imports sont nécessaires
import os  # pour nettoyer l'écran
import shutil  # pour avoir la taille du terminal
import textwrap  # pour afficher joliement les atomes
from time import sleep  # pour que ça aille pas trop vite

import colorama  # des couleurs dans le terminal ! (pip install colorama)
from colorama import Fore, Back
colorama.init()  # nécessaire pour windows


# quelques constantes utiles
SPEED = 0.5
TERM_WIDTH = shutil.get_terminal_size().columns
def clear(): os.system('cls' if os.name == 'nt' else 'clear')  # oui, c'est sale


# ça, ça va être notre classe propagateur. Notez que pour éviter de dupliquer
#  du code, on a écrit une méthode `print_atoms` qui s'occupe
#  d'afficher les atomes en couleur.
class ColorPropagator:
    # appelée une fois au début: on va dire qu'on va observer tous les atomes du programme
    def init(self, init):
        self.sleep = SPEED
        # On fait un dictionnaire pour se souvenir de la tête qu'à un atome,
        #  connaissant le littéral.
        # Notez que les atomes qui sont soumis aux exactes même règles
        #  (et donc qui sont vrais ou faux en même temps) ont le même litéral.
        # C'est pourquoi à un littéral (clef) on associe plusieurs valeurs
        #   (set d'atomes).
        self.__symbols = {}  # litéral du solveur -> set d'atomes
        for atom in init.symbolic_atoms:
            lit = init.solver_literal(atom.literal)  # on récupère le litéral
            init.add_watch(lit)  # on veut être prévenu lorsque sa valeur de vérité change
            if lit in self.__symbols:  # on l'ajoute au dictionnaire
                self.__symbols[lit].add(atom.symbol)
            else:
                self.__symbols[lit] = {atom.symbol}

    # la fonction appelée quand un litéral surveillé change de valeur.
    def propagate(self, ctl, changes):
        # ctl: le contrôleur
        # changes: la liste des litéraux qui ont changé de valeur
        # C'est assez simple: on dit à print_atoms d'afficher tout ça
        self.print_atoms(ctl.assignment, changes=changes)

    def undo(self, solver_id, assign, undo):
        # c'est globalement la même chose que propagate, juste avec un argument
        #  en plus qu'on utilise pas: solver_id.
        self.print_atoms(assign, changes=undo)

    # La fonction la plus complexe, qui n'a rien à voir avec les propagateurs
    #  en général.
    def print_atoms(self, assignment, changes):
        # assignment: objet qui peut donner pour chaque 
        clear()  # on nettoie l'écran
        to_print = ''
        # là, on boucle sur chaque littéral et atomes associés
        for idx, (lit, atoms) in enumerate(self.__symbols.items(), start=1):
            # quand un litéral est associé à plusieurs atomes,
            #  on les affiche tous, séparés par un point-virgule
            atom = ';'.join(map(str, atoms))
            fore, back = Fore.WHITE, Back.BLACK  # couleurs par défaut
            # assignment.value renvoie, pour un littéral donné:
            #  - True si le littéral est vrai
            #  - False si le littéral est faux
            #  - None si le littéral n'a pas de valeur de vérité
            if assignment.value(lit) is not None:  # donc, là, il a une valeur de vérité
                # s'il est vrai, on le met en vert (GREEN), sinon en rouge (RED)
                fore = Fore.GREEN if assignment.is_true(lit) else Fore.RED
                # si l'atome vient justement d'être changé, on le surligne en blanc
                if lit in changes: back = Back.WHITE
            elif lit in changes:  # C'est un undo
                # Effectivement, undo veut dire «enlever sa valeur de vérité à un atome»,
                #  donc, il ne passe pas la première condition. Mais il fait
                #  bien partie des atomes changé, donc on va le surligner aussi,
                #  mais en en bleu pour montrer que c'est un backtrack.
                back = Back.BLUE
            else:  # et sinon, il n'a pas de valeur et n'a pas été changé
                # on le laisse en couleur par défaut
                pass
            # maintenant on se prépare à l'afficher avec les couleurs sélectionnées
            to_print += fore + back + atom + Fore.RESET + Back.RESET + '  '
        # boucle terminée: on a généré toute la chaîne à afficher.
        #  pour rendre ça beau, on utilise textwrap et la taille de l'écran
        #  pour découper proprement les lignes.
        print('\n\n' + '\n'.join(textwrap.wrap(to_print, width=TERM_WIDTH)))
        # et on attend un poil, sinon on va rien voir.
        sleep(self.sleep)


# Et voilà notre main, qui ressemble à un main des plus standards.
#  Pas grand chose à dire dessus.
def main(prg):
    prg.register_propagator(ColorPropagator())  # on y met notre propagateur
    prg.ground([("base", [])])  # on grounde le programme de base
    prg.solve()  # et on résoud le problème !

# fin du python:
#end.
```

Le code réel est [ici](https://github.com/aluriak/learning-ASP/blob/master/propagators/color.py).
Il n'est pas très différent, mais largement moins annoté.


### Exemple de propagateur : graphviz/dot propagator
Celui-ci est carrément plus haut niveau, non par sa complexité, mais parce qu'il génère un fichier dans un format nommé *dot*.
Si vous ne connaissez pas le dot, sachez qu'il s'agit d'un format très utilisé pour décrire des graphes, au sens de la théorie des graphes.

La théorie des graphes et le dot sont tout à fait en dehors du scope de ce tuto, mais je vais essayer de faire court :
- un graphe, c'est un objet mathématique consistant en un ensemble de nœuds éventuellement reliés par des arêtes. C'est la structure de base en informatique, à partir de laquelle on dérive les autres. Les graphes sont utilisés dans tous les domaines : maths, physique, informatique évidemment, biologie, science sociales,… Vous en voyez souvent, sans vous en rendre compte.
- le dot, c'est une langue écrite, conçue par le projet graphviz, qui est aussi une suite logicielle. Les logiciels de graphviz sont capable de lire un programme en dot, et de générer une image ou d'autres fichiers qui représentent le graphe. C'est très puissant, car cela permet de voir graphiquement un graphe. C'est exactement ce qui nous intéresse.

Pour ce propagateur, nous allons donc exploiter le dot. L'idée est la suivante : un littéral est un nœud du graphe, et l'on trace un arc (une arête orientée, avec une flèche)
du nœud 1 vers le nœud 2 lorsque qu'une propagation assigne une valeur au littéral 2, et que la précédente assignait le littéral 1.
En d'autres termes, nous voulons visualiser le chemin emprunté par le solveur : dans quel ordre il assigne (et dé-assigne) les atomes/littéraux.

Le résultat est de facto très visuel : on génère des visualisations de graphes avec dot !

#### Le graphviz/dot propagator
Le code est disponible [sur mon github](https://github.com/aluriak/dot-propagator), et reproduit ci-après avec des annotations supplémentaires :

```asp
#script(python)
class DotPropagator:
    """A non-literal *dot* propagator"""

    # Cette fois-ci, notre classe est un poil plus complexe.
    #  Elle a un __init__, qu'on utilise pour préparer les conteneurs et le fichier dot
    def __init__(self, dotfiledesc:str):
        # dotfiledesc -- un descripteur de fichier dans lequel on peut écrire
        self.__dotfiledesc = dotfiledesc
        self.__stack = ['Start']  # c'est une pile de nœuds
        self.__step = 0  # pour pouvoir annoter les arcs
        self.__stable_nodes = set()  # tous les nœuds stables
        self.write_header()  # on commence par écrire des lignes obligatoires
        # C'est bon ! l'objet est prêt à faire propagateur !

    def init(self, init):
        # exactement comme pour notre premier propagateur: on suit tous les atomes
        self.__symbols = {}  # littéral -> set d'atomes
        for atom in init.symbolic_atoms:
            lit = init.solver_literal(atom.literal)
            init.add_watch(lit)
            if lit in self.__symbols:  # on l'ajoute au dictionnaire
                self.__symbols[lit].add(atom.symbol)
            else:
                self.__symbols[lit] = {atom.symbol}

    def propagate(self, ctl, changes):
        # ctl: l'objet de contrôle du solveur
        # changes: les littéraux qui ont reçu une valeur
        level = ctl.assignment.decision_level
        self.__step += 1
        # pour chaque changement, on va écrire dans le fichiers dot.
        for lit in changes:
            self.write('\t{} -> {} [label="{}"];'.format(self.last_node, lit, self.__step))
            self.push_node(lit)  # et on ajoute le litéral dans la pile

    def undo(self, sid, assign, undo):
        # sid: on s'en fiche
        # assign: ce sont les assignations de valeurs de vérité, on s'en fiche aussi
        # undo: les litéraux qui ont été changés
        while undo:  # tant qu'il y a un nœud dans les undo
            prev_node = self.pull_node()  # on récupère le sommet de la pile
            assert prev_node in undo  # par construction, il appartient aux nœuds qui sont retirés
            # on affiche le backtrack en dot avec une flèche en pointillé qui retourne sur le nœud actuel (la tête de pile).
            self.write('\t{} -> {} [style=dotted label={}];'.format(prev_node, self.last_node, self.__step))
            undo.remove(prev_node)  # on enlève le littéral de la liste des undo

    def check(self, ctl):
        # le solveur trouve que l'assignation est totale et valide : il s'apprête à générer l'answer set !
        # que faisons-nous ? On marque le nœud courant comme tel.
        self.__stable_nodes.add(self.last_node)


    # méthodes pour modifier le nœud courant (le sommet de la pile)
    def pull_node(self):  # le nœud courant devient le précédent
        *self.__stack, ret = self.__stack
        return ret
    def push_node(self, uid):  # nouveau nœud courant !
        self.__stack.append(uid)

    @property
    def last_node(self):  # juste un raccourcis pour le nœud courant
        return self.__stack[-1]

    def write(self, line):  # pour écrire du dot
        self.__dotfiledesc.write(line.rstrip() + '\n')

    def write_nodes(self):  # pour écrire les nœuds
        for uid, atoms in self.__symbols.items():
            self.write('\t{} [label="{}"{}];'.format(
                uid, ' '.join(str(atom.symbol) for atom in atoms),
                ' fillcolor="green"' if uid in self.__stable_nodes else ''
            ))

    # Deux méthodes pour les premières et dernières lignes du dot, qui sont toujours les mêmes
    def write_header(self):
        self.write('digraph solving {')
        self.write('\tnode [style=filled];')
    def finalize(self):
        self.write_nodes()
        self.write('}')


# Le main est assez standard également,
#  sauf le fait que l'on fait tout le solving avec un fichier ouvert,
#  que l'on donne à notre propagateur.
def main(prg):
    with open('out/out.dot', 'w') as fd:
        propagator = DotPropagator(fd)  # c'est notre propagateur !
        prg.register_propagator(propagator)  # on l'enregistre
        prg.ground([("base", [])])  # on ground
        prg.solve()  # on solve
        propagator.finalize()  # et on termine d'écrire le dot
#end.
```


#### Résultats sur cas simple
Voici un cas simple:
```asp
1{a;b}1.
1{c;d}1:-a.
1{e;f}1:-b.
```
Si vous ne comprenez pas bien ce qu'il fait, lancez clingo dessus. N'oubliez pas de regarder tous les answer-set.

<center>{% img {filename}/images/asp/dotpropagatorresult.png 700 "DotPropagator result for the simple case" %}</center>


#### Résultats sur cas compliqué


### Tips
`#count{}.%` est le plus simple des débuts de ligne que j'ai trouvé pour faire un commentaire à la fois en ASP et en Python. En Python, toute la ligne est ignorée, et en ASP `#count{}` ne produit aucune règle. Il s'agit donc bien d'un commentaire pour les deux langages.




### Multi-shot solving
TODO

### Iterative solving
TODO




# Conseils de style
*Où l'on s'imagine tel Gotlib mesurer au pouce cette pomme qu'il ne dessina jamais, mais en fait, non, ça n'a que peu à voir*

Cette partie est légère et calme : il s'agit de donner quelques conseils pour écrire de beaux codes.
Bien sûr, la beauté est subjective, et peut-être ces conseils seront-ils à jeter à la poubelle d'après une autre personne.

Ceci est vrai pour tous les langages en informatique : le style est quelque chose de subjectif.
Plus encore, c'est quelque chose qui dépend d'avec qui vous travaillez, et aussi du genre de code qui est écrit.

Certains languages ont la chance d'avoir un guide officiel, comme la PEP8 en python, d'autres non.
Certains languages ont une très forte culture de liberté de style, comme perl, d'autres non.

Bref, c'est au cas par cas. Mais en général, les conseils suivants s'appliquent :

- avoir un style consistant dans une base de code
- privilégier la lecture à l'écriture

Le premier est simple : il faut conserver la même manière d'écrire les choses (et de les nommer ; ça fait aussi partie du style).
Le second est plus compliqué, mais se retranscrit assez simplement : le nom de variable `i` est nul. Le nom `index` est mieux.
Sauf quand ça rend le code illisible. Mais là encore c'est subjectif.

Suivent donc quelques conseils de style pour les codes ASP.


## Premières lignes
Une volée de commentaires au début du code, expliquant le pourquoi du code, les entrées, les sorties, le comportement attendu,…
Ça semble évident, mais souvent «on oublie», parce que c'est chiant.

Pourtant, je ne saurais trop vous conseiller de prendre l'habitude d'écrire ça en premier.
Savoir *exactement* ce que l'on a et ce que l'on veut, c'est 50% du travail de modélisation.
Ça fixe les idées et aide à réfléchir.

## Commentaire d'accompagnement
Avant chaque règle (ou choix, ou contrainte), expliquer en commentaire ce qu'elle fait, à haut-niveau. Pas la peine de répéter le contenu de la règle,
mais expliquer ce qu'elle fait en gros permet d'avoir sans réfléchir le sens derrière une ligne de code.

```asp
% Les oiseaux volent.
fly(X):- bird(X).
```

## Aération
Laisser une ligne entre chaque règle (avec le commentaire qui l'accompagne), et laisser deux lignes pour marquer une grosse séparation.

```asp
% Les oiseaux volent.
fly(X):- bird(X).

% Le feu ne mouille pas.
not wet(X):- on_fire(X).
```

## Ordre logique
Souvent, les programmes sont divisés en plusieurs sous-parties logique, comme par exemple *données*, *expansion*, *modélisation*, *contraintes* et *affichages*.

A moins qu'elle ne soit placées dans un fichier dédié (ce qui est généralement préférable),
les données doivent être bien séparées du reste. C'est la partie mouvante du programme, dans le sens où il ne s'agit que d'une *instance* d'un problème général que le programme tente de résoudre.
Indiquer en commentaire le sens de ces données est également une bonne idée.

L'expension est un ensemble de règles qui permettent d'obtenir des données des informations qui seront nécessaires pour la modélisation. C'est une étape souvent inutile, car les données sont généralement bien faites de base. Mais dans certains cas (que nous rencontrerons après), il peut être intéressant de permettre des écritures simplifiées dans les données, qui seront *expansées* après.

La modélisation est, comme vous vous en doutez, l'ensemble de règles et choix qui implémentent la solution au problème et génèrent les solutions candidates.
Parfois, les contraintes font parties intégrantes de la modélisation, et ne devraient donc pas en être dissocié.
En effet, si l'ordre dans lequel les règles sont écrites ne compte pas pour le résultat, il vaut mieux qu'elle soient correctement ordonnée pour le lecteur humain.
Ainsi, si une contrainte fonctionne de concert avec une règle, il est souvent plus clair de ne pas les séparer.

Les affichages (`#show`) viennent souvent en dernier, car cela est assez logique, mais notez que ce n'est peut-être pas la meilleure solution.
Une bonne autre position pour les affichages serait… tout au début ! À côté des commentaires en premières lignes, qui indiquent les entrées du programme.
Avec les `#show` marqués explicitement, la documentation est réellement exhaustive, et ne fait pas doublon avec le code !
C'est génial de pouvoir placer les lignes où l'on veut !


## Des longueurs dans le texte
Évitez les lignes trop longues : elles sont illisibles, sont cassées par les éditeurs, ou nécessitent de scroller vers la droite : c'est pas un bon deal.
À la place, cassez vos règles, et usez des sauts de lignes pour étaler vos règles trop longues à la vertical, pas à l'horizontal.

```asp
je_suis_content :- passe_moi(le_beurre) ; passe_moi(le_sel) ; passe_moi(le_poivre) ; passe_moi(le_pain) ; passe_moi(le_couteau(beurre)) ; passe_moi(le_saussisson) ; passe_moi(le_couteau(saussisson)) ; passe_moi(les_cornichons) ; passe_moi(la_fourchette(cornichons)).
```

Est plus lisible lorsqu'écrit ainsi :

```asp
je_suis_content :-
    passe_moi(le_sel) ; passe_moi(le_poivre) ; passe_moi(le_pain) ;
    passe_moi(le_beurre) ; passe_moi(le_couteau(beurre)) ;
    passe_moi(le_saussisson) ; passe_moi(le_couteau(saussisson)) ;
    passe_moi(les_cornichons) ; passe_moi(la_fourchette(cornichons)).
```

C'est d'autant plus pratique que l'on peut maintenant commenter chacun des groupes de `passe_moi/1`, plutôt que tout commenter d'un coups avant ou après.


## Point-virgule et virgule
Ces deux caractères indiquent la même chose : le *et* logique.
Cependant, ils n'ont pas la même priorité.

`a:- b, c.` et `a:- b ; c.` sont strictement équivalents.
Mais, préférez le ; pour une raison simple :

`a(X):- val(X) ; b(X): c(X), d(X).` n'a pas du tout le même sens que
`a(X):- val(X) ; b(X): c(X) ; d(X).` !

Essayez avec les données `val(1..9).b(1;2).c(1;2).d(1).`.

Dans le premier cas, `d(X)` appartient à l'expression `b(X): c(X), d(X)`, qui est toujours vraie (`b(X)` est vrai lorsqu'on a `c(X)` et `d(X)`).
Dans le second, il n'y appartient pas, et est donc une condition supplémentaire, qui n'est vraie que pour `d(1)`.

Donc, mon conseil : utilisez toujours le point-virgule,
sauf lorsque vous devez utiliser une virgule.
Ça vous évitera d'avoir à retaper toutes vos virgules si l'un des terme d'une condition
devient une expression *pour tout* (`∀`).





# Real-world application
*Où, enfdeux, on touche du doigt l'intérêt d'être entré dans le monde merveilleux de l'ASP*


## Choisir l'itinéraire d'un réveil coureur
Un réveil coureur, c'est un réveil qui se met à courir partout lorsqu'il se met à sonner.
Intérêt principal : vous devez l'attraper avant de pouvoir l'éteindre. Autant vous dire que c'est efficace pour vous empêcher de vous recoucher,
surtout après un coups de tête dans le lavabo et un doigt de pied dans la porte.

Sauf que, aujourd'hui, les réveils coureurs ne sont pas très intelligents : ils courent au hasard,
et les développeurs espèrent juste qu'ils s'écrasera pas contre un mur.

Pour cet exemple, nous allons imaginer avoir un robot capable de se représenter dans l'espace en 2 dimensions
(c'est déjà de la science-fiction à ce niveau, mais passons). Notre objectif : faire le code qui permettra au robot de savoir où aller,
sachant qu'il doit aller réveiller tout le monde dans la maison, et ne s'arrêter qu'au fond du frigo, en étant passé par la cave avant.

Bref, il s'agit d'un parcours de graphe d'un point de départ au point d'arrivée, avec des jalons sur lesquels le chemin doit passer.
Notez que le contexte de l'exercice est assez ridicule, mais en vrai, parcourir l'espace et passer par des endroits particulier,
c'est une tâche assez standard en IA, très utile pour les jeux vidéos par exemple.

[Solution](https://github.com/Aluriak/learning-ASP/blob/master/path-search.lp).




## Placement de table, seconde approche
Après [la première approche](#placement-de-table-premire-approche) vient… la seconde approche !

Nous avons vu le placement bourrin de table, où l'objectif était de satisfaire toutes les contraintes.
Ça marche le plus souvent, mais si votre famille est trop compliquée, ça marche plus : le problème est juste insatisfiable.

Maintenant, plutôt que des contraintes, nous pourrions modéliser un *score* à maximiser.

Intuitivement, ce n'est pas tant qu'il *faille* que Tata Christelle et Tonton Robert soient à côté : c'est juste mieux. De fait, une telle combinaison augmenterais le score.
À l'inverse, mettre Gérard le Normand et Michel le Breton l'un en face de l'autre,
c'est lourd, mais c'est pas non plus une catastophe, donc on diminue le score.

L'intérêt est double : on va pouvoir hierarchiser les contraintes (toutes n'ont pas la même importance ; et à la limite les plus importantes peuvent rester des contraintes),
et on va pouvoir gérer des familles très compliquées, tellement compliquées que toutes les contraintes ne sont pas satisfiable simultanément.

<!-- Autre effet kiss-cool : clingo va chercher à maximiser le score, et chaque fois qu'il trouve une solution meilleure que la précédente, il l'affichera. On peut donc le laisser chercher jusqu'au bout, ou interrompre la recherche une fois que le temps est écoulé ou que la solution est suffisamment bonne -->

### Nuit de folie
Cette application est directe ; d'autant plus que normalement,
la famille ne change pas trop entre deux repas,
et comme on ne change généralement pas de table si souvent non plus… Le programme est réutilisable !

Et pas que avec les repas de famille : il marche également avec [les places au cinéma](https://xkcd.com/173/), les soirées entre amis,
les réunions de confrères de secte, les barbecues entre collègues, les fêtes des voisins, le pot de la chorale…
C'est fou l'informatique.





## Golfing
Le *golfing*, en informatique, est un jeu qui consiste à réaliser une tâche avec le moins de commande possibles.
Par exemple, le *vim golfing* consiste à changer un texte donné en un autre texte cible (donné également) en utilisant le moins de commande possibles au sein de l'éditeur vim.
Il existe aussi le *code golf*, qui consiste à faire un programme le plus court possible. C'est ça qui nous intéresse ici.

Si vous ne connaissez pas [codegolf.stackexchange](https://codegolf.stackexchange.com),
il s'agit d'une des instances de stackexchange (la plus connue d'entre elles étant probablement stackoverflow),
où les questions sont des challenges de *code golf*, où des centaines de programmeurs s'amusent à imaginer les programmes les plus courts possible,
dans une multitude de langages différents (parfois créés uniquement pour le *code golf*).
Le score correspond au nombre de caractères dans le code ; le but étant de faire le programme le plus court possible, il faut donc de minimiser ce score.

Nous allons nous intéresser au [**calcul de score du boggle**](https://codegolf.stackexchange.com/questions/143213/score-a-game-of-boggle),
car il est simple et nécessite un peu de python. C'est bon pour l'entraînement.

Nous allons voir qu'il est possible d'atteindre un score certes moins bon que
[python seul](https://codegolf.stackexchange.com/a/143218),
mais meilleur que les langages les plus verbeux comme java.

### Principes
Chaque joueur possède un ensemble de mot uniques d'au moins 3 caractères.
Le score d'un joueur est la somme des valeurs de ses mots.
Un mot trouvé par un autre joueur vaux zéro.
Un mot de 3 ou 4 lettres vaux 1 point. 5 lettres, 2 points, 6 lettres, 3 points, 7 lettres, 5 points,
8 lettres ou plus, 11 points.

### Données
Les données seront encodées avec un prédicat qui associe un numéro de joueur et les mots qu'il a trouvé.
Les contraintes sur les mots nous servent bien : un mot ne peut pas apparaître plus d'une fois pour un joueur.

Suit le premier exemple donné dans la question :

```asp
player(1,("cat";"dog";"bird";"elephant")).  % score: 12
player(2,("bird";"dog";"coyote")).  % score: 3
player(3,("dog";"mouse")).  % score: 2
```

Calculons ensembles le score du joueur 1: *cat* donne 1 point, *dog* et *bird* ont été trouvés
par d'autres joueurs et donnent donc 0 point, et *elephant* donne 11, soit un total de 12 points
pour le premier joueur. De notre point de vue, cela veux dire que nous devons générer `score(1,12)`.

### Méthodologie

Déjà, nous avons besoin de déterminer quels sont les mots qui compterons pour le score.
Une première solution est de dire que 1 et 1 seul joueur à trouvé le mot.
L'autre solution est que, sachant un joueur l'ayant trouvé, tous les autres ne l'on pas trouvé.

```asp
unique(P,W):- 1 { player(_,W) } 1 ; player(P,W).
% ou, c'est équivalent :
unique(P,W):- player(P,W) ; not player(P2,W): player(P2,_) P2!=P.
```

Maintenant que l'on sait quels mots doivent être comptés dans le score pour chaque joueur,
il est temps de se poser la question du score lui-même :

```asp
score(P,S):- S = #sum{L: unique(P,W), value(W,L)} ; player(P,_).
```
L'atome `score(P,S)` associe un joueur et son score final,
obtenu en faisant la somme des valeurs *L* des mots *W* qui sont uniques et associés au joueur.

Le problème de cette approche, c'est la génération automatique de `value(W,L)`.
En effet, en ASP, il n'est pas possible d'obtenir la longeur d'une chaîne.
Par conséquent, nous allons faire un peut de magie avec python:

```asp
#script (python)
def value(word):
    return len(word.string)
#end.
```
Notons que la valeur est facilement calculable en python, en utilisant le snippet utilisé [ici](https://codegolf.stackexchange.com/a/143218):

```asp
#script (python)
def value(word):
    return [1,1,2,3,5,11][min(len(word.string),8)-3]#end.#show s/2.
#end.
```

Et voilà, nous pouvons accéder à la valeur d'un mot W avec `@value(W)`. Que c'est magnifique !
Il serait possible d'encoder le mapping de la taille et de la valeur en ASP ainsi:

```asp
value(3,1).
value(4,1).
value(5,2).
value(6,3).
value(7,5).
n(8..99).
value(X,5):- n(X).
```
Mais l'inconvénient est triple : c'est long, il y a une génération de nombreux atomes inutiles,
et ça oblige à donner une limite supérieure à la taille des mots.

Donc, on garde la fonction python qui fait la totalité du mapping mot -> score,
ce qui nous permet de l'appeler dans la somme, et on obtient le code total suivant :

```asp
unique(P,W):- 1 { player(_,W) } 1 ; player(P,W).
score(P,S):- S = #sum{@value(W): unique(P,W)} ; player(P,_).
#script (python)
def value(word):
    return [1,1,2,3,5,11][min(len(word.string),8)-3]
#end.
```

Wow ! On obtient bien les bons scores pour chaque joueurs :
`score(1,12)`, `score(2,3)` et `score(3,2)`.

Maintenant que le programme fonctionne, il ne reste plus qu'à le *golfer*, et à compter les caractères.
Voici donc notre script final, atteignant un score de 137 caractères,
ce qui le place avant-avant dernier (devant PHP et Java) au moment où j'ai écrit ce programme :

```asp
u(P,W):-1{p(_,W)}1;p(P,W).s(P,S):-S=#sum{@v(W):u(P,W)};p(P,_).#script(python)
def v(w):return[1,1,2,3,5,11][min(len(w.string),8)-3]#end.
```

Notez que les données d'entrées doivent être encodées avec le prédicat `p` à place de `player`.
Aussi, la directive de script ignore le reste de sa ligne, par conséquent,
faire un one liner parfait est impossible ici.


### Golf du Mexique
Évidemment, cet exemple n'est pas là pour servir directement,
à moins que vous ne jouiez vous-même au boggle.

L'intérêt est qu'il montre que bien des jeux, même ceux avec des règles complexes,
peuvent être encodés en ASP pour être résolus ou étudiés.

Et aussi, ça montre que parfois, ASP donne de bonne solutions pour le *code golf* (et des fois, [non](https://codegolf.stackexchange.com/questions/44485/score-a-game-of-kingdom-builder/51777#51777)).

Amis golfeurs, je vous salut !





## Construire un PC
Ici, on va s'intéresser à un jeu de lego : construire une machine.

Cela pourrait vous servir un jour, et sinon, c'est toujours rigolo à faire.
Aussi, nul besoin de vous y connaître en PC, les explications viennent avec (ce tuto est inter-disciplinaire).

Ce genre de programme s'organise autour de deux principaux programmes :
celui qui récupère les données, c'est-à-dire les pièces de pc disponibles,
comme par exemple les cartes graphiques, les processeurs, les boîtiers,…
et celui qui construit le pc à partir des pièces récupérées, c'est-à-dire
qui choisi quelles pièces utiliser.

Le mot-clef, vous l'aurez compris, c'est *choisir*, et il se trouve dans la seconde
catégorie. L'interface avec un distributeur de matériel informatique n'est pas
le sujet de ce tuto, donc on s'arrangera avec quelques données faites à la main.

Mais si un jour quelqu'un veux s'amuser, la première étape est tout à fait automatisable,
par exemple en tapant dans l'API d'un distributeur qui en propose une.


### Spécifications
Une machine est un ensemble de plusieurs pièces : CPU, GPU, RAM, carte mère, refroidissement, disque dur, SSD, boite, périphérique.
Chacune de ces *catégories* doit se voir assigner une (et une seule) pièce, ou éventuellement zéro si la catégorie est optionnelle
(par exemple, je peux vouloir un SSD *si possible* ; c'est donc optionnel)

Chaque pièce appartient donc à une catégorie, et possède un prix, des dépendances et des incompatibilités.
Aussi, elles auront chacune une note de *préférence* : je pourrais ainsi dire *je préfère la GPU 1080 à la 1070*
en mettant une plus grande préférence sur la première.

Enfin, et c'est là tout le sel : on ne veux pas dépasser un prix maximum.

### En clair
On veut un programme ASP qui, en considérant les pièces disponibles, nos préférences personnelles, les interdépendances
entre les pièces, et un prix maximum, soit capable de nous donner une bonne solution, voir la meilleure.

Là où ASP est génial, c'est qu'il n'y a pas besoin de connaître grand chose en heuristique pour résoudre ce genre de problème
(qui, j'en suis sûr, se réduit [au problème du sac-à-dos](https://fr.wikipedia.org/wiki/Problème%20du%20sac%20à%20dos), et par conséquent est NP-complet).

Le code le plus récent est disponible sur [le dépôt](https://github.com/aluriak/learning-ASP/blob/master/build-pc.lp).
Nous allons ici l'aborder point par point.


### Commentaires
Nous allons étudier le programme, découpé en 5 parties.
Les premières parties sont de la pure description,
nous allons donc nous contenter de décrire des faits,
comme par exemple *cette GPU est trop cool*,
ou *ce composant est incompatible avec celui-là*.

Les dernières parties vont implémenter le moteur réel, la partie du programme
qui va utiliser les faits pour en déduire une configuration valide d'ordinateur.
C'est ici que nous trouverons les contraintes et les directives de maximisation.


#### Données
Tout d'abord, nous déclarons les données que nous allons utiliser,
c'est-à-dire les pièces disponibles, pour chaque catégories,
avec leur nom et leur score (qui représente à quel point la pièce nous intéresse).

```asp
component(gpu,"A",330,10).
```

Ici, le composant de catégorie GPU, sobrement nommé *A*, coûte 330€ et est noté 10/10,
autrement dit, cette GPU, c'est notre préférée.

Les deux autres GPU accessibles sont données avec les trois lignes suivantes.

```asp
component(gpu,"B",200,7).
component(gpu,"embedded graphic chipset",0,4).
require(gpu,"embedded graphic chipset",cpu,"C").
```

Les deux autres GPU étant moins bonnes, leurs prix et notes sont moins hauts (voir nuls pour la *C*, mais il s'agit d'une puce graphique intel, ce n'est donc qu'une solution par défaut).

##### Dépendances
Notez l'atome `require/4` qui nous permet de définir que la puce intégrée
nécessite le CPU *C*, et par conséquent (la règle qui s'en assure sera vue plus tard)
que le choix de cette GPU oblige à utiliser le processeur qui l'embarque (c'est assez logique, finalement).

Néanmoins, si on choisi le cpu *C*, nous ne sommes pas obligés de choisir la puce intégrée,
laissant le champs libre pour une autre carte graphique plus puissante.
(la logique étant que la puce intégrée ne prend pas l'emplacement de la carte graphique, c'est juste un module du processeur ; personnellement mon processeur possède une puce intégrée, mais je ne l'ai jamais utilisée, j'ai une vraie carte graphique à côté que j'utilise à la place)

##### Les autres composants
CPU, RAM, SSD, HDD,… Tous vont passer dans la grande moulinette de l'ASP.
Je vous invite à regarder le code pour avoir une idée de toutes les pièces qui seront utilisées.




#### Préférences
Les choix concernant le build : pièces optionelles, importances relatives.
#### Connaissances du domaine
Pas très utilisé pour le moment, mais donne un exemple simple de ce qui pourrait y être placé.
#### Expansion des données
De l'interface haut niveau aux atomes pour la couche d'en dessous.
#### Modèle
C'est ici que le principal se passe.

Maintenant que toutes les préférences



### Aller plus loin
#### Réflexion de fond d'informaticien
Vous noterez que nous avons définis des couches successives d'abstractions : par exemple, nous utilisons `require/4` au lieu d'écrire une contrainte,
laissant une règle dan l'expansion des données s'occuper de créer la contrainte associée.

Ce principe rapellera à certain les *Domain Specific Language* (DSL), des languages utilisés dans un projet pour décrire un modèle de donnée.
Ces DSL ont beaucoup d'applications, et vous voyez que dans une certaine mesure, ASP permet d'en créer. Ici, nous avons créé un DSL
pour décrire les pièces d'ordinateur et leurs relations.

Là où c'est plus fort, c'est que vous pouvez aller plus loin : permettre à l'utilisateur de décrire les tâches qu'il veut faire avec son PC
(les logiciels qu'il utilise, notamment, comme les jeux ou la bureautique qu'il veut faire tourner),
et en déduire plus de contraintes sur le PC final : pas la peine d'avoir plus de 2GB de RAM
si l'utilisateur final veut juste lire ses mails ou se connecter aux réseaux sociaux (4GB pour l'OS Windows),
et à l'inverse, une puissance minimale de GPU peut être nécessaire pour certains jeux.

Vous pouvez facilement imaginer ASP comme un générateur de DSL : c'est ce que je fait avec [Biseau](https://gitlab.inria.fr/lbourneu/biseau).


#### Attrapez les toutes
Déjà, une première étape, c'est effectivement de récupérer les données, i.e. les pièces disponibles et leurs relations.

Évidemment, récupérer TOUTES les pièces possibles est un peu long,
alors avoir des informations en amont, notamment les prix minimaux et maximaux (globaux, et par catégorie)
permet déjà d'élaguer. En général, toute limitation est bonne à prendre : taille de la RAM, du stockage, nombre de cœurs…

Tout cela est facile à intégrer dans le programme ASP : il ne s'agit que de rajouter des pièces,
des préférences, voir des contraintes.

Une solution pourrait être de parser ou chopper l'API d'un site de vente
de matériel, par exemple [LDLC](https://www.ldlc.com/configurateur-pc/)
ou [partpicker](https://pcpartpicker.com/).


#### Dans le ¬Sephiroth
Une fois que les deux premières parties sont mises en place et travaillent ensemble,
vient l'étape de distribution de votre projet révolutionnaire : d'autres personnes pourraient en bénéficier.

Une manière de faire, c'est une interface web, où les utilisateurs peuvent checker
les pièces disponibles qui les intéressent, éventuellement faire un peu d'apprentissage pour proposer
des pièces intéressantes (si 80% des utilisateurs qui prennent 8Go de RAM choissisent aussi une 1080,
alors automatiquement proposer une 1080 à tout utilisateur qui prend 8Go de RAM).

La deuxième étape, c'est de constituer la base de donnée et de préférence de l'utilisateur
en fonction des composants qu'il a choisi et des indications qu'il a donnée.

Enfin, il faut faire tourner le solveur
([dans le navigateur du client](https://github.com/aluriak/webclingo-example)
grâce à du [webassembly](https://fr.wikipedia.org/wiki/WebAssembly)
parce que nous vivons déjà dans le futur),
et de sortir les meilleurs *build* au client.

Et paf, vous vous faites connaître, [r/buildapc](https://www.reddit.com/r/buildapc/)
devient votre source d'utilisateur principale,
et vous devenez riche grâce à un système comme [*coinhive*](https://coinhive.com),
qui bien sûr, dans le futur, est bien plus mature, éthique, démocratisé,
et contrôlable par l'utilisateur final.


### PC construit, nuit de folie
Cet exemple ne sera pas utile tel quel à tout le monde, mais vous comprenez bien que vous pouvez l'adapter un peu pour,
par exemple, choisir le meilleur portable disponible en fonction des fonctionnalités qu'on vous vend,
faire les sandwichs pour la randonnée de demain en fonction de ce qu'il y a dans le frigo,
ou plus généralement de décider comment faire quelque chose en fonction des limites.

J'ajouterais aussi que mettre à plat ce genre de chose aide beaucoup à faire un choix rationnel.
Et en plus, le solver vous donne la meilleure solution juste en connaissant vos goûts !

Magique ? Non, informatique !



## Clustering conceptuel
Ne prenez pas peur en lisant cette expression : c'est en fait assez simple.

Notez que cet exemple se base en grande partie sur les propagateurs.

### Clustering
Le clustering, c'est une opération visant à séparer en groupes un ensemble d'éléments.
Dans la vie de tous les jours, on en fait beaucoup : notre cerveau est même spécialement entraîné à ce genre de tâche.

Quand j'essuie la vaisselle, il faut savoir où mettre quels ustensiles : les fourchettes dans le bac à fourchettes, les assiettes sur la pile d'assiette (de même couleur).
C'est du clustering : on range des éléments (les ustensiles) dans des groupes spécifiques (pile à assiette, bac à fourchette)
en se basant sur les propriétés de l'objet (une fourchette, ça ressemble à une fourchette, donc ça va dans le bac à fourchette).

De manière intéressante, ce clustering apparemment trivial se complexifie dés lors que vous avez des ustensiles qui ne tombent dans aucune catégorie, comme la [cuiller-fourchette](https://fr.wikipedia.org/wiki/Cuill%C3%A8re-fourchette) (ou *spork*, en anglais).
Où mettre ces ustensiles qui appartiennent à plusieurs catégories ? Selon les personnes, le choix peut se faire de manière rationnelle, en ajoutant une propriété sur un groupe donné
(*le bac à fourchette* devenant par exemple *le bac à tout ce qui a 2, 3 ou 4 pics métalliques allongés*). D'autres le feront au hasard, ou d'autres choisirons sur d'autres critères (on a moins de cuiller, donc le bac à cuiller a de la place pour la cuiller-fourchette dedans).

Concernant les objets qui ne rentrent dans aucune catégorie, c'est exactement le problème que résouds *le plat qui est dans l'entrée* :
un dépotoir où l'on met tous les objets que l'on ne sait pas ranger dans les groupes existants.

Bref, du clustering, c'est très naturel comme opération. En mathématiques, évidemment, la chose est attaquée avec plus d'abstraction.

### Clustering conceptuel
Le clustering conceptuel est en réalité plus proche encore de notre manière de fonctionner : cela consiste à avoir,
pendant le clustering même, un avis critique sur les groupes constitués.

Par exemple, lorsque l'on remplis des cartons pour un déménagement, on essaye d'avoir une cohérence de contenu : un carton doit contenir un type d'objet
(il y a donc, selon le théorème du plat dans l'entrée, un carton *de bordel* qui contient ce que l'on ne sait pas grouper).

Le clustering parfait, ce serait d'avoir un minimum de cartons, remplis avec le même type d'objets,
tous de même taille et masse qu'un humain peut porter facilement.

Cependant, contrairement à l'exemple de la vaisselle où l'on a une bonne connaissance des objets qui sont clusterisés (on sait ce qu'on a comme vaisselle, et a peu près combien, et que l'on a tous les conteneurs adaptés),
faire ses cartons vient avec la difficulté que l'on ne se rend pas compte de tous ce qu'on a accumulé, et que les cartons sont en nombre choisis a priori
(a moins que vous n'ayez fait une simulation de déménagement avant qui vous aurais permis de déterminer le volume exact nécessaire à contenir vos possessions).

Donc, pendant la mise en carton des objets à déménager, on fait un clustering conceptuel : on prend un objet, on cherche le meilleur carton pour le contenir,
et si d'instinct on sens que cet objet n'est pas le seul de son type, on ouvre un nouveau carton pour l'y mettre.
Au bout de quelques heures, on vide un carton qui n'était pas si remplis, pour y vider la moitié d'un carton trop lourd,
et on dispatch les objets vidés dans d'autres cartons en fonction d'autres critères.

(Évidemment, on travaille généralement de manière plus intelligente : pendant que gégé met les livres dans un carton (qui sera trop lourd, de fait), dom' met les assiettes dans un autre. Mais au delà de ces cas précis… il y a souvent du bordel à trier, et à un moment, des cartons à refaire)

C'est cela le clustering conceptuel : prendre les objets un par un, et sans connaissance des prochains objets, faire un clustering.
Ce clustering va évoluer au fur et à mesure des objets ajoutés, et parfois être complètement modifié suite à l'arrivée d'un objet qui change tout.

### Le problème à résoudre
L'énoncé est le suivant : nous avons 10 valeurs, qui peuvent donc être groupées dans au maximum 10 groupes, et au minimum, un seul.


### Programme ASP
Le programme ASP suivant s'occupe de la partie clustering : génération des données, et choix de groupements.

Comme ce qui nous intéresse, c'est les groupes de valeur et non pas l'identifiant du groupe, on use de `#project` pour éviter de générer des clustering équivalents
(par exemple, mettre une valeur toute seule dans le cluster 1 ou 2, ça revient au même : ce qui compte, c'est que la valeur est seule).

```asp
value(1..3).
cluster(1..3).

% 0 ou plus valeur dans chaque cluster.
0 {cluster(C,V): value(V)} :- cluster(C).

% Une valeur ne doit appartenir qu'à un seul cluster.
1 {cluster(_,V)} 1 :- value(V).

% Le numéro de cluster n'est pas pertinent.
same_group(A,B):- cluster(C,A) ; cluster(C,B).
#project same_group/2.
```

Vous pouvez tester ce programme : chaque modèle est une solution de clustering différente. Oui, il y en a plus de 100000.
Non, j'ai pas eu la patience d'attendre qu'ils soient tous écoulés.

Et oui, avec un clustering conceptuel, on peut éviter la génération de bien des modèles.

### Squelette du propagateur



## Résoudre un donjon de The Legend of Zelda
### Contexte
Dans sa franchement intéressante série [*Boss Keys*](https://www.youtube.com/watch?v=ouO1R6vFDBo&list=PLc38fcMFcV_ul4D6OChdWhsNsYY3NA5B2),
Mark Brown, un designer professionnel dans le milieu du jeu vidéo, cherche, épisode par épisode, à comprendre la structure interne et les logiques
qui sous-tendent les donjons des jeux de la licence [The Legend of Zelda](https://fr.wikipedia.org/wiki/The%20Legend%20of%20Zelda%20(s%C3%A9rie)).

Si vous aimez cette série de jeu, ou le game design en général,
je ne peut que trop vous conseiller *Boss Keys*, et plus généralement son excellente chaîne,
[*Game Makers Toolkit*](https://www.youtube.com/channel/UCqJ-Xo29CKyLTjn6z2XwYAw).

Lorsqu'on regarde *Boss Keys*, au fur et à mesure des épisodes on s'aperçoit que Mark Brown
imagine, formalise et améliore, vidéo après vidéo, un langage qui lui permet de définir formellement les donjons des jeux.
Dans les derniers épisodes, le langage devient vraiment complet et descriptif.

Sans surprise, le langage est un [graphe](https://fr.wikipedia.org/wiki/Graphe%20orient%C3%A9), qui donne des informations précises sur la répartition dans l'espace et le temps
des objets et mécanismes qui constituent les donjons, et permet à Mark Brown de délimiter la *solution* du donjon,
c'est-à-dire la succession d'actions à opérer qui permettent, à la fin, d'ouvrir la porte du *boss* avec la clef dédiée
(d'où le nom de la série, *boss keys*).


### Notre boulot
En lisant les lignes précédentes, une idée vous est venue : si nous avons accès à une représentation formelle des donjons du jeu,
et que nous pouvons formellement décrire les actions et les buts, alors il serait possible d'écrire un programme qui,
comprenant le langage de description de Mark Brown, serais capable de décider d'une solution au donjon.

Bien sûr, vous vous doutez que si j'en parle ici, c'est parce que nous allons nous y intéresser avec ASP.

Voici une image piquée de la vidéo [*The Legend of Zelda: A Link Between Worlds' dungeon design | Boss Keys*](https://www.youtube.com/watch?v=E7sm-0nGV34) :

<center>{% img {filename}/images/asp/zelda_mark_brown_dungeon.png 700 "Zelda dungeon representation by Mark Brown" %}</center>

On voit bien le départ, la fin (*boss*, en bas), et les différentes étapes qui mène à la résolution du donjon.
On comprend bien ici qu'une solution au donjon est un parcours de ce graphe qui part du départ et arrive au boss
en ne passant par les obstacles que lorsque la clef ou l'outils associé est possédé.


### Modélisation
Petit rappel sur le langage développé par Mark Brown, i.e. la représentation en graphes des donjons :

- les nœuds sont des salles, ou zones du donjon portant un objet d'intérêt.
- deux nœuds sont reliés si il existe un passage entre les deux.
- un objet d'intérêt est soit un obstacle, soit un objet à ramasser.
- un obstacle ne peut être contourné/annulé que par un objet.
- un objet à ramasser est sois un outils, soit une clef.
- une clef est à usage unique, mais ouvre n'importe quel obstacle qui attend une clef.
- un outil est soit la clef du boss, qui permet d'ouvrir la porte du boss, soit un objet de l'univers du jeu (grapping, arc, bottes,…).

Donc, en clair : il faut ramasser une clef pour pouvoir annuler un obstacle qui nécessite une clef (une porte verrouillée, donc),
ou dans le cas des autres obstacles l'objet associé à l'obstacle
(pour annuler un obstacle de type *arc*, il faut que l'objet *arc* ait été ramassé auparavant).

Notez que le graphe n'est pas orienté. Néanmoins, on peut imaginer l'intérêt de l'orientation :
des passages ne pouvant être pratiqués que dans un seul sens par le personnage
(porte de sortie, toboggan,…).

Notez également que le langage est en fait un poil plus complexe, car il a une composante graphique importante
(le placement des nœuds dépends de l'ordre dans lequel les objets/obstacles doivent être traités).
Nous allons néanmoins ignorer cela, car (1) tout le sel est de laisser l'ordinateur faire la résolution totale,
et (2) l'information de l'ordre est redondante, et n'est là que pour faciliter la lecture pour les humains qui regardent la vidéo/l'image.


### Le code
D'abord, la définition du donjon.

```asp
% Dungeon objects.
% onedoor(g).
keydoor(g).
keydoor(b;f).
% door(D):- onedoor(D).
door(D):- keydoor(D).
key(c;e).
% one(d).
key(d).
open(start).  % links starts the dungeon

% Links between doors
link(start,(b;c;d)).
link(b,(e;f)).
link(f,g;g,stop).
```

Et ensuite, la définition de la solution :

```asp
% Doors next to open doors are accessible
accessible(Door):- link(Open,Door) ; open(Open).

% Doors with objects inside are opened freely.
open(ObjDoor):- accessible(ObjDoor) ; key(ObjDoor).
open(ObjDoor):- accessible(ObjDoor) ; oner(ObjDoor).

% Doors that are opened using one non-used key.
open(KeyDoor,Key):- accessible(KeyDoor) ; keydoor(KeyDoor) ; open(Key) ; key(Key) ;
                    not open(KeyDoor,OtherKey): key(OtherKey), OtherKey!=Key ;
                    not open(OtherDoor,Key): keydoor(OtherDoor), OtherDoor!=KeyDoor.

% Doors that are opened using a reusable object.
% open(OneDoor,One):- not open(OneDoor) ; accessible(OneDoor) ; open(One) ; one(One).
% open(TwoDoor,Two):- not open(TwoDoor) ; accessible(TwoDoor) ; open(Two) ; two(Two).

% Keep in mind which object opened which door.
open(Door):- open(Door,_).


#show.
#show open/2.
```

### Généralisation
Évidemment, le donjon de zelda, ce n'est qu'un prétexte pour attaquer le principe de planification d'une tâche,
qui ici n'est pas **du tout** réalisé de manière optimale. Déjà, l'étape suivante, ce serait de passer ça en résolution incrémentale.

Dans la langue de Batman, on parle de [*planning*](https://fr.wikipedia.org/wiki/Planification).
C'est un sujet de recherche où il y a beaucoup de choses à faire, surtout en ASP.




# TCC: The Conclusive Conclusion
*Où l'on apprend que tout ceci n'était que le début, car en réalité, l'informatique est bien plus qu'un langage qui fait des trucs rigolos*




# Liens
## Autres applications
- [ASP for FCA](https://github.com/Aluriak/ASP-for-FCA) un ensemble de programmes qui utilisent ASP pour exprimer des concepts (*pun intended*) de l'[Analyse de Concepts Formels](https://fr.wikipedia.org/wiki/Analyse%20de%20concepts%20formels).
- [une page](http://www.hakank.org/answer%20set%20programming) très complète avec beaucoup d'exemples et de programmes avec explications.
- Au sein [du projet pygarden](https://github.com/IndexErrorCoders/pygarden), [solasp](https://github.com/IndexErrorCoders/pygarden#solasp) est un code ASP qui permet d'optimiser le placement de plantes dans le jardin sachant leurs préférences de voisinage.
- [pytest-asptest](https://github.com/aluriak/pytest-asptest) : un plugin pytest pour faire des tests unitaires sur des codes ASP.
- [clyngor](https://github.com/aluriak/clyngor) : un package pour appeler et gérer clingo depuis python


## And now, for something totally different
- Tuto/howto pour [utiliser clingo en javascript, côté client](https://github.com/aluriak/webclingo-example).
- N'hésitez pas à poser des questions sur ASP sur [stack-overflow](http://stackoverflow.com/questions/tagged/answer-set-programming).
- la page [potassco/teaching](https://potassco.org/teaching/) regorge de liens.
- une erreur ? une idée ? une question ? Ça se passe sur [le dépôt du blog](https://github.com/aluriak/blog-content).
- If you want to help for the english version, it's [here](https://github.com/aluriak/blog-content/blob/master/articles/tuto-asp%20en.mkd).




# Solutions aux exercices
*Où l'on constate qu'effectivement, les exos étaient pas compliqués, mais que la soupe à l'avocat, elle, était horrible*

### Notation
`k/3`, `coucou/0` et `symballium/10`.

### Tel père, tel fils
```asp
enfant(Enfant,Papa):- papa(Papa,Enfant).
```

Pour le bonus :
```asp
mechant(dark_vador;zurg).
nooooooooooon:- moi(E) ; papa(P,E) ; mechant(P).
```

### Mon papa c'est le meilleur
```asp
papa(P):- papa(P,_).
1 { meilleur_papa(P): papa(P) } 1.  % ou papa(P,_), mais sans la règle précédente ça revient au même
```

### Garde contre et roi de trèfle
Les deux règles suivantes sont équivalentes dans ce contexte :
```asp
on_joue_au_ballon:- -on_joue_au_tarot.
% équivalente à :
on_joue_au_ballon:- copain(C) ; not en_recre(C).
```

### Yodel et papier crépon
Une première solution, qui génère aussi les sous-ensembles de solutions :
```asp
2 {peoples(X): aime(X,_) }.
2 {subject(Y): aime(_,Y) }.
:- not aime(X,Y) ; peoples(X) ; subject(Y).
```

Pour éviter les sous-ensembles, une solution est d'obliger un sujet aimé de toutes les personnes d'être membre de la solution :
```asp
subject(Y):- aime(X,Y): peoples(X) ; aime(_,Y).
```

Vous remarquez que le code ressemble alors à la seconde solution, qui est en fait beaucoup plus simple :
```asp
peoples(X):- aime(X,_) ; aime(X,Y): subject(Y).
subject(Y):- aime(_,Y) ; aime(X,Y): peoples(X).
:- 2>{peoples(_)}.  % au moins deux personnes
:- 1>{subject(_)}.  % au moins 1 sujet
```


*[ASP]: Answer Set Programming
*[answer set]: Un ensemble réponse, un modèle valide contenant un ensemble d'atomes qui sont tous vrais
*[CPU]: Computing Processing Unit, le processeur.
*[GPU]: Graphical Processing Unit, la carte graphique.
*[QPU]: Quantum Processing Unit, pour le moment c'est de la SF.
*[BPU]: Brain Processing Unit, est à l'interface chaise-clavier ce que le CPU est à un ordinateur.
*[RAM]: Random Access Memory, la mémoire vive.
*[HDD]: Hard Drive Disk, un disque dur, qui contient le stockage.
*[SSD]: Solid State Disk, le successeur des disques durs, vachement plus rapides.
*[POO]: Programmation Orientée Objet, un paradigme où les concepts sont séparés et doivent interagir par envoi de messages
*[PF]: Programmation Fonctionnelle, un paradigme où les fonctions sont manipulées au même titre que les types de base
*[la vie réelle]: Un lecteur critique pourrait se demander «la vie réelle de qui ?». Il paraît que je vis dans un autre monde, parfois.
