Title: Introduction à Answer Set Programming (ASP)
Date: 2017-03-31
Modified: 2017-03-31
Tags: asp, language, tuto
Authors: Lucas Bourneuf
Summary: un tuto pour ASP
Slug: tuto-asp
Lang: français
Translation: false
Status: draft


<br/>

[TOC]

<br/>


# Introduction

Cet article est un tuto qui se veut accessible sur [Answer Set Programming](https://en.wikipedia.org/wiki/Answer%20set%20programming),
un langage de programmation déclaratif implémentant la *Programmation Par Contrainte*,
ou PPC (comme java implémente la POO et haskell la PF).

Pour ceux qui connaissent, il fera certainement penser à [Prolog](http://www.learnprolognow.org/),
puisque ces deux langages reposent sur les même concepts, bien qu'ils ne l'implémentent pas de la même manière.
Pour les matheux, il fera penser à TLA+, en beaucoup moins puissant, certainement.

L'objectif n'est pas seulement d'apprendre les bases en faisant joujou,
mais de développer des programmes qui résolvent des problèmes de la vie réelle,
éventuellement avec quelques lignes en plus pour pouvoir être réellement utilisés dans la vie de tous les jours.

Dans une certaine mesure, ce tuto s'adresse aussi à ceux qui n'ont jamais codé ;
après tout, les langages logiques sont les meilleurs pour commencer :)
(je fais un effort de simplification durant tout le tuto, justement pour permettre à des personnes n'ayant jamais codé de s'y intéresser néanmoins)


## Quelques liens préliminaires
*Où l'on se demande pourquoi faire un tuto si c'est pour renvoyer tout le monde voir ailleurs*

Je conseille volontier la lecture parallèle d'un tuto existant ; ça aide toujours d'avoir
plusieurs sources pour comprendre un concept.
Pour être franc, je n'ai trouvé que [celui-ci](https://cjamcl.com/blog/a-gentle-introduction-to-asp/) (en anglais),
qui passe très vite sur les bases.

Les scripts utilisés ici sont disponibles
sur le dépôt [learning-ASP](https://github.com/Aluriak/learning-ASP).
Vous pouvez les télécharger, et même participer à leur développement si besoin.

Notez aussi que clingo, le groundeur/solveur que nous allons utiliser,
est accompagné [d'un manuel bien fournis](http://sourceforge.net/projects/potassco/files/guide/),
d'un [nombre impressionnant d'exemples de tous types dans ses sources](https://github.com/potassco/clingo/tree/master/examples)
(j'insiste ; faites y un tour, il y a un exemple pour presque toute les fonctionalités du solveur),
et [d'une mailing list active](https://sourceforge.net/p/potassco/mailman/potassco-users/)
où beaucoup de questions intéressantes sont posées.
(il y a [une autre mailing list](https://lists.sourceforge.net/lists/listinfo/potassco-announce)
pour les annonces des développeurs, typiquement les nouvelles versions)


# Concepts généraux
*Où l'on découvre à quelle sauce nous allons être mangés*

## Principes de Programmation Déclarative
Comment collecter tous les entiers positifs inférieurs à 100 et multiples de 3 ?
En python, une manière de faire est la suivante (à droite, après le `#`, il s'agit de commentaires qui ne sont pas interprétés par la machine, qui sont là juste pour l'humain) :

```python
for nb in range(0, 100):  # pour chacun des nombres de 1 à 100
    if nb % 3 == 0:       # si le nombre est un multiple de 3
        print(nb)         # afficher le nombre à l'écran
```

Ce qu'il y a à voir ici, c'est que l'on explique au programme exécutant le code (ici, l'interpréteur python)
**comment** arriver à la solution qui nous intéresse.
Ce paradigme, dit *impératif*, consiste à expliquer **comment calculer la solution**.

C'est une approche qui est en fait assez peu naturelle, et ça se voit quand on commence la programmation.
C'est effectivement assez consternant de devoir s'expliquer auprès d'un ordinateur qui semble avoir
les capacités de compréhension d'un enfant de 5 ans (et c'est encore pire avec les langage de bas-niveau),
et c'est un gros problème dans l'enseignement en informatique.

La programmation déclarative aborde le problème d'un angle différent :
l'humain ne doit plus expliquer **comment** atteindre la solution,
mais plutôt la **décrire**,
c'est à dire répondre au **quoi**, ce qui est beaucoup plus naturel pour un humain.
Le paradigme *déclaratif* consiste en l'explication du **quoi**.

HTML est un bon exemple de langage déclaratif: on décrit bien la solution (la structure finale de la page web).
Le HTML n'est pas un langage impératif ; d'ailleurs,
si la page finale dépend de paramètres extérieurs (compte enregistré par exemple),
vous ne pouvez plus compter uniquement sur le HTML.
C'est généralement là qu'interviennent des langages *impératifs* (Javascript, PHP, Python, Java,…)
qui permettent de générer du HTML à partir de templates et des paramètres extérieurs.

Sans ces languages, il faudrait avoir en mémoire toutes les solutions possibles,
ce qui n'est pas possible pour une grande partie des sites web, et difficilement maintenable.


## Principes de Programmation Logique
Le paradigme logique est un sous-ensemble du paradigme déclaratif.
Autrement dit, un langage *logique* est un langage *déclaratif*.
À l'inverse, un langage *déclaratif* n'est pas nécessairement *logique* (le HTML, par exemple, n'est pas logique).

Le paradigme logique repose sur les méthodes formelles issues des maths et de la théorie de la logique
C'est avec ces outils que la description de la solution (la réponse au **quoi**) est formulée.

C'est précisément à cette catégorie de langage qu'ASP appartient.

Pour présenter un peu le concept de la programmation logique,
imaginons un langage qui nous permettrais d'expliquer ce qu'est
la solution au programme python vu précédemment (calculer les nombres entre 1 et 100 qui sont multiples de 3) :

```
euh… ben, tout les nombres qui sont multiple de 3, tu vois, mais
entre 1 et 100. Et puis, «nombre» oui, mais pas ceux à virgule, hein.
Ouais, décimaux, c'est ça.
```

Ce langage possède deux propriétés attractives :
la majorité des francophones le comprendrais, ET ils seraient capable de
le réutiliser pour exprimer le même problème, ou une variation
(les multiples de 4, ou les nombres de 1 à 200,… Essayez chez vous, vous verrez, c'est facile).

Le problème, c'est qu'aujourd'hui en informatique, créer un programme qui
comprendrais ce language relève encore de la science-fiction.
Hors, et c'est bien là l'objet de ce tuto, on veut utiliser l'ordinateur
(et un ordinateur de bureau, hein, pas un super calculateur et
l'équipe de chercheur en langage naturel qui va avec).

Donc, essayons maintenant de faire un language que nos petits ordinateurs puisse comprendre :

```
x tel que : x est un entier, 1 < x < 100, x est un multiple de 3.
```

C'est compréhensible, simple et efficace ; c'est de la programmation logique !
Ce langage précis n'est pas implémenté (et ASP est un peu moins haut niveau (i.e. proche du langage naturel) que cela),
certes, mais il s'agit d'un exemple d'approche d'un langage expressif.
On remarque bien ici qu'il ne s'agit finalement que de *décrire* la solution.

La [page wikipédia française sur la programmation déclarative](https://fr.wikipedia.org/wiki/Programmation%20d%C3%A9clarative)
est courte, mais suffisante pour notre étude.


## Principes de Programmation Par Contrainte
Nous pouvons définir une *contrainte* comme *une restriction sur les solutions*.
En d'autres termes, la programmation par contrainte consiste
à ajouter des expressions qui écartent des solutions,
qui sinon seraient autorisées.

C'est un moyen efficace de s'assurer qu'une propriété est respectée dans toutes les solutions.

À propos de notre exemple sur les nombres de 1 à 100 divisibles par trois, nous pouvons trouver quelques contraintes :
*«seulement des nombres entiers»*, ou encore *«doit être divisible par trois»*, ou bien *«doit être inférieur à 100»*.

En vérité, les contraintes sont très naturelles dans nos langages naturels.

«*Deux joueurs ne peuvent commencer à une distance de moins de 5 mètres*» pourrait dire un designer de jeu.

«*Un taxon ne peut appartenir à deux branches*» dira le phylogénéticien.

«*Je ne peux pas mettre plus de deux packs de lait sur le support arrière du caddie*» dis-je pendant mes courses.

Bref, il est souvent plus simple (et moins coûteux) d'exprimer une contrainte plutôt qu'inclure
cette restriction dans la génération de la réponse elle-même.

En général, un langage autorisant la programmation par contrainte pourra être divisé en deux parties :

1. définir les possibles solutions (modélisation de l'espace de recherche)
2. interdire les résultats qui ne nous intéressent pas (contraintes)

La première partie, c'est la *génération*, où l'on génère les candidats pour la solution.
Comme en général ces candidats ne sont pas tous bons, on besoin de les filtrer,
d'où la seconde étape, *l'application de contraintes*,
qui permet de définir quels candidats seront écartés.
(digression-culture: ce n'est pas le seul usage des contraintes, mais on verra ça bien après)

Answer Set Programming est un langage logique où les contraintes
font partie du langage autant que le reste des déclarations.
Néanmoins, la dichotomie entre génération et contraintes se voit dans beaucoup de codes ASP,
car les développeurs ont intuitivement ce découpage dans leur réflexions.



# Outillage
*Où l'on va enfin faire quelque chose ; dommage que ce soit pas très intéressant*

Il existe [de nombreuses implémentations d'ASP](https://en.wikipedia.org/wiki/Answer%20set%20programming#Comparison%20of%20implementations),
chacunes avec des approches uniques
et intéressantes pour résoudre des problèmes plus ou moins spécifiques.

Pour ce tuto, nous allons utiliser la suite [Potassco](https://potassco.org), un ensemble de logiciels
qui gravitent autour d'une idée : implémenter et utiliser ASP.
Plus particulièrement, nous allons utiliser *clingo*.

(si ça vous motive et que vous êtes à l'aise, prenez une autre implémentation ;
en général les différences conceptuelles du langage
ne seront pas monstrueuses, mais certaines implémentations proposeront des fonctionalités différentes.

Cela étant dit, suivre un tuto avec les bons outils, c'est pas plus mal.
Bref, faites comme vous voulez, mais dans le doute, utilisez clingo et explorez les autres après si l'envie vous en prend)


## Clingo, en deux (cents) mots et deux parties
Si vous ne comprenez rien au charabia de cette, pas d'inquiétude : c'est juste pour fixer les idées des informaticiens.
Lisez tout de même, je met quelques simplifications au milieu.

Clingo est à ASP ce que CPython est à Python:
une usine à gaz (un gros programme bien compliqué) qui comprend et applique les effets de bord du langage.
<!-- Faut vraiment que je fasse un article sur ces notions -->

Clingo est en fait constitué de deux composantes: *gringo* et *clasp* (que l'on peut récupérer et utiliser à part).

Gringo est à ASP ce que [le compilateur de CPython](https://docs.python.org/3/library/dis.html) est à Python, ou ce que gcc est à C:
une grammaire et un ensemble de routines
qui compilent vers un langage simplifié à l'extrême.
(dans le cas d'ASP, c'est du [smodels](http://www.tcs.hut.fi/Software/smodels/), pour CPython c'est le bytecode, et pour C c'est l'assembleur)

Clasp est à ASP ce que l'interpréteur de CPython est à Python :
un ensembles de routines qui pigent le langage simplifié calculé par l'outils précédent (gringo/compilateur)
et en appliquent les effets de bord (mémoire et calculs).

Pour être plus précis à propos de gringo et clasp, le premier compile un programme
qui suit la grammaire d'Answer Set Programming (et un peu plus, nous verrons cela),
et le second est une routine qui, à l'aide d'une heuristique très personnalisable,
va chercher les solutions acceptables (ou *modèles stables*) dans le programme compilé.

En ASP, on parle de *grounding* pour la partie assurée par *gringo*,
et de *solving* pour la partie assurée par *clasp*.
Clingo est donc un programme qui se charge du grounding et du solving
d'un seul coups.

De notre point de vue, c'est ça en moins à gérer, mais c'est important de s'en rendre compte,
car dans pas mal de cas il peut être intéressant de manipuler les deux indépendemment.


## Installation
il est possible de [faire tourner clingo dans un navigateur](https://potassco.org/clingo/run/).
C'est très pratique : il n'y a rien à installer, ça marche tout seul,
pas besoin de se prendre la tête.

Si vous voulez savoir comment ce bijoux technologique est possible,
allez voir [l'issue à propos](https://github.com/potassco/clingo/issues/66),
et [mon exemple fonctionnel](https://github.com/Aluriak/webclingo-example).

Si toutefois vous préférez utiliser votre environnement de dev favori,
et que vous vous sentez de faire deux clics gauche et un clic droit,
Clingo est disponible sur le [dépôt github](https://github.com/potassco/clingo/releases).
Le site de référence étant [le site de Potassco lui-même](https://potassco.org/doc/start/).

À l'écriture de ce tuto, la version de clingo la plus récente est la 5.2.3.


### Installation manuelle
A moins que vous ne soyez concerné par l'un des quelques OS qui ont un packaging,
le plus simple est probablement de

1. Télécharger ou compiler le binaire *clingo*
2. Le mettre dans le PATH (`/usr/bin` pour les bourrins, `~/.local/bin/` pour les moins bourrins)

*Qu'est-ce que le PATH ?*
[Pour les windowsiens](http://sametmax.com/ajouter-un-chemin-a-la-variable-denvironnement-path-sous-windows/),
[pour les unxiens](http://generation-linux.fr/index.php?post/2008/10/15/Changer-les-dossiers-par-defaut-dans-le-PATH).

Personnellement, j'ai un répertoire `~/bin/` vers lequel mon PATH pointe. C'est ici que j'y ai mis
mes binaires clingo:

```
❯ ls -lA ~/bin | cut -c 50- | grep clingo
clingo521
clingo454
clingo -> clingo521
```

(clingo est un lien symbolique vers l'une des versions installée… généralement la plus récente)
<!-- [comme pour les binaires python]({filename}/articles/the-python-ecosystem.mkd) -->

### Compilation
Pour les plus à l'aise, la compilation de clingo depuis les sources est aussi possible,
et nécessaire si vous voulez une version particulière avec le support de python
ou de lua avec une version particulière (je pense à python 3, notamment)

Voici le makefile que j'utilise sous fedora pour l'update, la compilation et l'installation :

```makefile
all: update_repo compile install

install:
	cp clingo/bin/clingo ~/bin/clingo_compiled_from_repo

compile:
	cd clingo && cmake -H. -B.  -DCMAKE_BUILD_TYPE=Release -DPYTHON_LIBRARY:FILEPATH=/usr/lib64/libpython3.5m.so -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.5m -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.5m
	cd clingo && make
	cd clingo && cmake --target test -H. -B.  -DCMAKE_BUILD_TYPE=Release -DPYTHON_LIBRARY:FILEPATH=/usr/lib64/libpython3.5m.so -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.5m -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.5m
	cd clingo/app/clingo/tests && python3.5m run.py --clingo ../../../bin/clingo run

update_repo:
	cd clingo && git pull
	cd clingo && git submodule update --init --recursive
```



## Quelques tests préliminaires
*Où l'on commence à jouer, avec une retenue typique d'une centrale hydroélectrique*

Maintenant que vous avez clingo qui fonctionne, effectuons quelques
tests préliminaires pour étudier un peu l'environnement.

### Version
Pour avoir la versions de clingo, il suffit de demander: `clingo --version`.
Vous verrez quelque chose du style:

    clingo version 5.2.1
    Address model: 64-bit

    libgringo version 5.2.1
    Configuration: with Python 3.6.2, with Lua 5.3.4

    libclasp version 3.3.2 (libpotassco version 1.0.0)
    Configuration: WITH_THREADS=1
    Copyright (C) Benjamin Kaufmann

    License: The MIT License <https://opensource.org/licenses/MIT>

On peut, notamment, voir les versions de gringo et clasp utilisées,
ainsi que les supports de langages de scripts (ici python et lua sont supportés tous les deux,
ce ne sera peut-être pas votre cas, selon la manière dont vous l'avez installé/compilé/récupéré).


### Le «bytecode» d'ASP
Il est possible de voir la sortie de gringo avec l'option `--text`. Avec ce flag,
clasp ne sera pas appelé et ne sera retourné que le code simplifié issu du grounding.
(pour ceux qui passe par le navigateur : il ne semble pas y avoir d'options pour le voir, mais il existe, soyez en sûr)

Lorsque l'on utilise ASP pour un problème combinatoire, il arrive souvent que l'on
s'intéresse au grounding du programme.
C'est en effet en étudiant ce code intermédiaire qu'il sera possible de déterminer
quelles règles en ASP génèrent beaucoup de données,
et donc quelles règles sont impliquées dans un temps de solving long.


## Lancez la machine !
Lancez clingo sur les fichiers contenant les programmes de ce tuto, ou lancez le sans fichier en argument,
et tapez directement le programme, puis contrôle-D (fin de fichier).
Clingo vous répondra en fonction.

Prenez **vraiment** l'habitude de lancer les programmes, et de les trifouiller.
C'est comme ça qu'on apprend !
(pour ceux qui sont dans leur navigateur : copiez-collez les programmes dans la zone de texte, modifiez-les à l'envie, et appuyez sur *run*)

Pour bien montrer comment clingo s'utilise, voici
une session complète où j'écris un programme ASP
dans l'entrée standard de clingo (j'aurais aussi pu l'écrire directement dans l'entrée standard clingo) :

    ❯ echo "a. b." > program.lp
    ❯ clingo -n 0 program.lp
    clingo version 5.2.1
    Reading from stdin
    Solving...
    Answer: 1
    a b
    SATISFIABLE

    Models       : 1
    Calls        : 1
    Time         : 0.000s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
    CPU Time     : 0.000s

(pour ceux qui sont dans l'interface web, juste ajoutez `a. b.` dans le champs de texte, et appuyez sur run)

Du point de vue de clingo, que se passe-t-il ici ?

- d'abord, clingo parse les arguments de la ligne de commande (ici `-n 0` et `program.lp`)
- il apprend que je veux *touts* les modèles, toutes les réponses possibles (`-n 0`)
- il apprend également que le programme est intégralement contenu dans `program.lp`
- il lance gringo sur le programme, et obtient le code groundé.
- il lance clasp sur le code groundé, et m'affiche le résultat
- j'apprend que mon programme n'a qu'une seule et unique solution (*Answer: 1*), où les atomes a et b sont vrais.

Notez que la ligne `Reading from program.lp` correspond au grounding, et la suivante, `Solving...`, correspond au solving.

Si clingo semble ne rien faire après avoir écrit la première, c'est que le grounding est long (et le pc ne fait pas *rien* ;
vous avez probablement un CPU qui tourne à 100% pendant toute la durée du grounding).
Dans l'autre cas, c'est le solveur qui pédale dans la semoule.


### help et options diverses
Vous pouvez avoir l'aide de clingo avec l'option `--help` (ou `--help=3` pour l'aide complète ; encore une fois, ceux qui sont sur le navigateur ne peuvent pas lancer ces commandes,… désolé).
Quelques options intéressantes dont je ne parlerais pas ou peu :

- `--text`: pour avoir le code groundé (le solveur, clasp, n'est pas appelé). Cf `--mode`.
- `--stats`: pour avoir plus d'info sur le déroulement du solving lorsque celui-ci est terminé (il y a une checkbox sur l'interface web)
- `--time-limit`: permet de donner un temps maximum de grounding/solving
- `--parallel-mode`: utiliser le multithreading : utiliser plusieurs cœurs en même temps pour le solving
- `--enum-mode`: choix de l'énumération des modèles : *tous les modèles*, ou *tous les meilleurs modèles* par exemple
- `--outf`: choix du format de sortie (l'un des plus intéressant est probablement JSON, si vous voulez récupérer le résultat sans faire de parsing manuel)


# Principes d'Answer Set Programming
*Où l'on va (enfin !) faire quelque chose de significatif dans ce monde où seule l'action prime*

Maintenant que l'on a plein de théorie dans la tête et clingo sur le pc,
attaquons le vif du sujet: parler ASP !

## Commentaires
Les commentaires sont des parties du texte que clingo ne va pas considérer.
Pour le dire autrement, vous pouvez mettre les pires cochonneries dans des commentaires,
clingo ne se formalisera pas.
En général, c'est très utilisé par les humains pour expliquer
à quoi sert le code qui est à côté.
Utiliser les commentaires aide à comprendre ce que fait un code ; il est donc conseillé d'utiliser les commentaires pour s'aider soi-même.

Les commentaires commencent par un `%`:

```asp
% Je suis un commentaire
Je ne suis pas un commentaire  % ni de l'ASP valide d'ailleurs
```

Ici, clingo plante sur `Je ne suis pas un commentaire`, car il ne s'agit pas d'ASP valide. Comme indiqué dans le commentaire à droite.

Les commentaires multilignes commencent avec `%*` et terminent avec `*%`.
Notez que clingo n'est pas capable de gérer la présence d'un `%*`
dans un commentaire multiligne, ni ne considère ce qu'il y a après un `%`,
empêchant d'utiliser le snippet `% *%` comme le `//*/` en C.


## Les atomes
Un atome est un fait, une relation qui est considérée vraie.
Par défaut, tout atome est considéré faux, jusqu'à ce
qu'il soit explicitement statué comme vrai.

Un programme ASP repose sur ce principe,
si bien que la solution à un problème est en fait décrite
par les atomes vérifiés.

Tout le jeu d'un programme ASP est de définir quels atomes doivent être vrais,
sous quelles conditions (c'est la modélisation du problème),
et quelles combinaisons d'atomes rendent une réponse caduque (c'est le job des contraintes).

Considérons le programme suivant:

```asp
a.
```

Ici, on indique que le *fait* `a` est vrai.
À l'inverse, tout autre fait est faux, et si on lance clingo sur ce programme,
nous ne trouverons qu'un seul et unique modèle (ou (ensemble-)réponse) : celui où `a` est vrai.

Le point `.` est un peu comme le point-virgule en C,
ou le saut de ligne en Python : il termine chaque règle et atome du programme.
Si vous oubliez un point, vous aurez droit à une erreur de type `unexpected machin-bidule bla bla bla`.

```asp
a(4).
```

Cette déclaration est un peu plus complexe, mais revient au même : le prédicat `a` d'arité 1
(c'est-à-dire avec 1 argument) avec comme premier (et unique) argument `4`, est vrai.

De la même manière, il est possible de déclarer `b`, `b(42)`, mais aussi `a(b)`, `a(a,b,c,3)`, `a(b(1))`, ou encore `a(a(b(b(9))))`.
Le nombre d'argument potentiel est virtuellement illimité, et un atome peut être argument d'un autre.

L'usage typique des arguments, c'est de donner des valeurs à un concept, par exemple:

```
papa(jacques_dutronc,thomas_dutronc).  % J. Dutronc est le papa de T. Dutronc
papa(dark_vador,luke_skywalker).  % Pareil pour dark vador et luke
papa(chronos,zeus).  % idem
papa(zeus,athena).  % bref, vous avez compris
papa(zeus,hercule).
papa(geb,isis).
papa(geb,nephtys).
papa(geb,osiris).
papa(zurg,buzz).
```

Voilà, toutes ces données sont considérées vraies par clingo (et en plus sont vraies dans réalité véritable, que demander de plus ?).
Bien sûr, on ne va pas s'amuser à les mettre dans tous les programmes qu'on utilise :
ça a beau être vrai, ce n'est pas toujours pertinent.


## Notation
`a/1` est l'ensemble des atomes de prédicat `a` avec un seul argument. Par exemple `a(1)` ou `a(a(a(staying,alive)))`.
De la même manière, `ha(do,pi)` et `ha(do,ken)` appartiennent tout deux à l'ensemble des atomes décrits par `ha/2`.

Questions (sans piège) : comment décrire l'atome `k(2,"mille",v(2))` ?
`coucou` ?
Et `symballium(v,o,l,u,m,e," ",I,V,"<3")` ?

(si vous n'êtes pas sûr de vos réponses, allez voir la fin de page)


## Retour sur les atomes
Ci-après, un autre programme qui génère des atomes
(donc, des *faits*, des éléments considérés vrais pendant le solving).

```asp
% Les atomes nb(X) sont vrais pour tout X entier de 1 à 100.
nb(1..99).
% Les atomes nb_ex(X) sont vrais pour tout X ∈ [1;4]
nb_ex(1;2;3;4).
% On peut aussi combiner les deux:
nb_cb(1;2;3..10).
```

Donnez ce programme directement à manger à clingo !
Vous comprendrez vite comment ça fonctionne.


## Règles
Maintenant que l'on peut déclarer des faits, nous pouvons commencer à déclarer
des règles de causalité.
En d'autres termes, il est possible de définir qu'un atome est vrai sous certaines conditions.

En ASP, cela se fait avec l'opérateur `:-`, une espèce de *si* :

```asp
% l'atome ok est vrai SI l'atome a est vrai
ok :- a.
% l'atome ok est vrai SI les atomes b ET c sont vrais
ok :- b ; c.  % notez que le ET est symbolisé par le point-virgule
```

On appelle la partie *avant* le `:-` la *tête* (head),
et la partie à droite le *corps* (body).
La tête est vraie si et uniquement si le corps est vrai.

Les règles sont les premiers éléments utiles dans un programme ASP.
Ce sont ces règles qui vont permettre d'exprimer des implications,
et donc de réellement commencer à travailler sur les atomes existants.

Donc, dans un programme ASP, vous avez des atomes considérés vrais (souvent, ce sont des données du problème),
et des ensembles de règles qui vont permettrent d'inférer la véracité d'autres atomes.


## Variables
Les variables permettent d'écrire des règles plus généralistes.
Tout mot commencant par une majuscule est une variable.

Par exemple:
```asp
% l'atome ok(X) est vrai si l'atome a(X) est vrai
ok(X) :- a(X).
```

Avec ce programme, si `a(2)` est vrai, alors `ok(2)` le sera également.
Même chose pour n'importe quelle valeur de X, de `1` à `a` en passant par `-42000`, `"i have υτφ-8 characters"` ou `a(b(c(d,d(3),e(f,g(a(b,8)),0))),k20,flip,flop(py(disk)),"hello, world!")`.

Exemples de règles avec des variables :

```asp
% L'atome nb_3(X) est vrai pour tout X positif inférieur à 100 et multiple de 3.
nb_3(X) :- 0 < X ; X < 100 ; X \ 3 = 0.  % le '\' c'est pour le modulo, ou "division entière"
% l'atome entoure(X-1,X,X+1) est vrai si l'atome a(X) est vrai
entoure(X-1,X,X+1):- a(X).  % par exemple, avec a(2), ça donne entoure(1,2,3)
```

### Variable muette
La variable muette, c'est une manière de dire explicitement : *cette valeur ne m'intéresse pas*.
Par exemple, si je voulais avoir un atome d'arité 1 qui me donne les papas, indépendemment de leurs enfants,
je pourrais faire ainsi :

```
papa(P):- papa(P,E).
```

Sauf que le `E` qui sert à rien là, c'est pas très joli. Du coups, on peut le remplacer par une variable muette :

```
papa(P):- papa(P,_).  % une variable muette commence par un _ ('underscore')
```

Et voilà ! Il est bien clair pour tout le monde que le second argument ici ne nous intéresse pas.
Il faut qu'il existe, évidemment, mais la valeur exacte n'est pas pertinente dans le contexte.

Notez qu'on pourrait tout à fait se passer des variables muettes. Elles sont tout à fait optionnelle.
C'est ce qu'on appelle du *sucre syntaxique* : un truc sympa qui ne fait que simplifier la vie du programmeur.


## Exeeeeerciiiiiiice ! Tel père, tel fils
Petit exercice à faire chez vous, c'est obligatoire, sinon, lorsque vous commencerez à lire la partie suivante,
ce site s'autodétruira (offre soumise à condition).

Je vous propose simplement de reprendre la base de donnée des pères présentée plus haut
(avec `papa(jacques_dutronc,thomas_dutronc)` et les autres),
et de faire un programme qui, connaissant ces liens de parenté, va définir qui est l'enfant de qui.

En clair, si j'ai `papa(monpapa,moi).`, je veux obtenir `enfant(moi,monpapa).`.

Pour réussir ce petit tour, il faut utiliser les deux concepts vus précédemments : les règles et les variables.

### Aide
Si au bout de 20 minutes vous :

- **n'avez rien essayé :** bah quoi ? Allez-y ! **Tapez des trucs !** Si ya bien un domaine où il faut se tromper pour y arriver, c'est l'informatique ! Et l'ordi il est là pour ça vous savez ; et il aura oublié aussi tôt que vous aurez essayé autre chose. À moins que vous ne soyez détenu par un psychopathe qui vous observe et vous oblige à faire ce tuto ? Et qu'à la moindre erreur, il vous fait boire une soupe d'avocat ? Si c'est le cas, je suis désolé que ça tombe sur mon tuto, mais cela étant dit, je suis assez content d'avoir vu juste. Envoyez moi un mail quand vous serez sortit de là, hein ? Ça me rassurera. Et puis, dans votre malchance, vous avez de la chance : ya vraiment rien de *compliqué*. Nouveau, oui, mais il faut savoir sortir de sa zone de confort. Par contre, j'avoue, la soupe d'avocat c'est un peu sévère. Bref. Concentrez-vous, vous allez y arriver, faites vous confiance (par contre, dépêchez-vous, la soupe d'avocat froide, c'est encore pire ! … désolé).
- **n'avez rien essayé, malgré le fait qu'aucun psychopathe ne vous menace avec une soupe d'avocat :** là, il va falloir se lancer, hein (et revenez ensuite, hein ?).
- **toujours pas trouvé, malgré bien des tentatives :** en bas de page, ya les solutions.

### Bonus
Un atome `moi/1` permet d'indiquer qui je suis. Si mon père est Dark Vador, alors l'atome `nooooooooooon` doit être vrai.


## Négation
Notez qu'il est possible d'utiliser la négation:

```asp
% l'atome ko(X) est vrai pour tout X de nb_ex(X) qui n'est pas ok(X)
ko(X):- nb_ex(X) ; not ok(X).
```

Notez que le point-virgule est utilisé comme opérateur *et*, l'équivalent de `and` en Python ou `&&` en C.

Une autre manière de voir cette règle, plus verbeuse mais plus puissante, est la suivante:
*Pour tout X tel que nb_ex(X) est vrai et ok(X) est faux, on a ko(X)*.

Cette formulation nous permettra de mieux comprendre une prochaine construction du langage.

Il n'existe pas réellement de *ou* en ASP ; il faut alors créer 2 règles, chacune implémentant un cas :

```asp
% l'atome ok(X) est vrai si nb_ex(X) ou si nb_in(X)
ok(X):- nb_ex(X).
ok(X):- nb_in(X).
```


## Disjonction (choix)
Une construction très importante en ASP est le *choix*.
Le choix consiste en un… choix. C'est dur à expliquer autrement.

Voici un exemple simple, avec le résultat donné par clingo,
qui consiste en un choix de exactement 1 parmis 3 atomes :


```
❯ echo "1 { a ; b ; c } 1." | clingo -n 0
clingo version 5.2.1
Reading from stdin
Solving...
Answer: 1
b
Answer: 2
c
Answer: 3
a
SATISFIABLE

Models       : 3
Calls        : 1
Time         : 0.000s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.000s
```

La sortie de clingo est toujours très semblable à celle-ci.
Les données importantes sont les différentes réponses possibles (et leur nombre).

(notez que sans l'option `-n 0`, seul un modèle aurait été montré. le `n`
est en fait la version courte de *nombre de modèle à afficher, ou 0 pour tous les afficher*.
Notez que, si des modèles n'ont pas été affichés à cause de cette option, clingo
le fera savoir en affichant un `+` à côté du nombre total de modèles calculés)

La première réponse (ou *modèle*, ou *answer set*, ou *ensemble réponse*),
contient uniquement l'atome b.
La seconde contient uniquement l'atome c.
Enfin, la dernière réponse contient uniquement l'atome a.


### Pourquoi pas deux en même temps ?
C'est vrai ça ! Pourquoi on pourrait pas avoir *a* et *b* en même temps par exemple ?

Résonnons par l'absurde : si on a *a* et *b* en même temps, cela veut dire que a et b sont vrais dans le même modèle.

Or, dans le programme, il est dit `1 { a ; b ; c } 1.`, c'est-à-dire qu'au moins une et qu'aau plus une
des trois valeurs entre accolades est vrai.
Si *a* et *b* sont vrais, alors il y a deux valeurs vraies parmis les valeurs entre accolades,
ce qui n'est pas possible, puisqu'il doit n'y en avoir qu'une !

En suivant la même logique, on devine qu'il ne peut pas non plus y avoir *a*, *b* et *c* en même temps,
ni aucun des trois.


### Pourquoi cet ordre ?
Parce qu'en ASP, on travaille sur des *set* (answer *set* programming).
Les *set*, *ensemble* en français, au sens mathématique du terme,
sont des ensembles **non ordonnés** d'éléments **uniques**.

Les conséquences de ces propriétés sont les suivantes :

- les réponses ne sont pas ordonnées (nous verrons que… mais c'est pour plus tard)
- un atome ne peut pas être *choisi* deux fois : soit il est vrai, soit il ne l'est pas. Il ne peut être vrai deux fois (car cela reviendrait à avoir deux fois le même élément dans un *set*)
- l'ordre des règles en ASP n'a pas d'importance (contrairement à Prolog, vous pouvez donc mélanger les lignes de votre programme sans que cela n'ait d'effet : allez-y, testez, c'est rigolo ! (nan, en vrai, c'est chiant comme une course d'escargot en ralentit pendant la nuit : il se passe rien))

Gardez cela à l'esprit, car ces propriétés sont fondamentales dans
la construction mathématique derrière ASP, et donc dans les notions que l'on va voir après.


### Retour à nos moutons
Le programme traité par clingo est le *choix* suivant : `1 { a ; b ; c } 1`,
qui se traduit *un élément parmis a, b ou c*.
Le 1 à gauche est la borne minimale, par défaut égale à zéro.
Le 1 à droite est la borne maximale, par défaut l'infini.

Si le programme avait été `2 { a ; b ; c } 2`, j'aurais également eu trois modèles/réponses,
mais leur contenu exact aurait changé:  `a b`, `b c` et `a c` sont les trois ensembles possibles de deux éléments parmis a, b et c.

De la même manière, si le programme était `{ a ; b ; c }`, j'aurais eu 8 modèles.
Et si il était `{ a ; b ; c } 2`, j'aurais eu 7 modèles.
Pourquoi 8 et 7 ? Je vous laisse tester vous-même,
vous comprendrez tout de suite.

(remarquez que tout cela n'est que pure [combinatoire](https://fr.wikipedia.org/wiki/Combinatoire))


Aller, un dernier exemple pour la route, qui montre comment avoir un seul `nb(X)` vrai pour chaque answer set:

```asp
% On choisis un nombre entre 1 et 100.
1 { nb(1..100) } 1.
```

Vous pouvez (devriez) vérifier : nous obtenons bien 100 answer sets, chacun avec sa propre valeur de nb(X).


## Exeeeeerciiiiiiice ! Mon papa c'est le meilleur
Un petit exercice tout simple : encore avec la base de donnée des papa, choisir le *Papa de l'Année*, titre honorifique
qui sera officiellement décerné lors d'une grande fête intergalactique.

Votre tache, si vous l'acceptez (et vous êtes obligés, sinon la fête est annulée et tout le monde va vous en vouloir, surtout l'infâme Zurg, et il est vachement rancunier alors je serais vous je ferais vachement gaffe), est de choisir le *Papa de l'Année*.

Bon, avec un grand pouvoir vient de grandes désillusion : les grandes fêtes intergalactique, je vous le cache pas, c'est surtout une occasion de revoir la famille lointaine et d'essayer ce nouvel alcool fort de tonton Gaston.
Du coups, quelque soit le papa que vous choisissez, il y aura des bastons et des gens qui hurlent.

Donc, comme on aime bien investir, nous, les illuminatis-de-l'espace-qu-on-contrôle-toute-la-galaxie-tavu, nous sommes dit
que ce serais pas mal d'avoir un programme qui choisi pour tout le monde. Pas de jaloux, c'est le hasard.

Du coups, allez-y : faites un programme ASP qui choisi un papa. Et nous, les illuminatis-de-l'espace-qu-on-contrôle-toute-la-galaxie-tavu,
on prendra le premier modèle (ou le second. Ou le dernier. Bref, celui qui nous arrange, mais chut c'est tip-top-secret !).

### Aide
Si au bout de 20 minutes, vous:

- **n'avez rien essayé :** j'en déduit que la soupe d'avocat est bonne. Perso, la seule fois où on en a fait, j'étais tout petit, y avait mon papa et ma maman qui avaient fait la soupe. Ben personne n'en a mangé. C'était. Vraiment. Pas. Bon. En vrai, rien qu'à l'odeur, on a tous fait des têtes bizarres. Et ensuite ma maman elle a goûté, et ensuite elle nous a défendu d'en prendre. Plus tard, dans ma fratrie, la légende racontait (racon*tait*, hein, parce que bon, maintenant on a grandit, on sait tous que je l'avais inventée juste pour faire mon intéressant, en qu'en vrai c'était juste l'hiver) que, après que les parents l'ai jetée dans le compost, les plantes ont arrêtée de pousser pendant plusieurs mois.
- **n'avez rien essayé, mais êtes bien conscient qu'il faut se lancer, mais au font avez trop peur qu'en appuyant sur la mauvaise touche, je sorte de l'écran, bouillant de rage, en hurlant des insanités et en maudissant votre famille sur 29.3 générations :** un indice : avec deux expressions, ça se fait bien.
- **avez tout essayé, y compris de faire une méta-méta-heuristique qui contrôlait un algo génétique multi-agent qui testait des combinaisons au hasard de lettre pendant plus de 25 ans sur un supercalculateur :** il y a les solutions en bas de page, mais en vrai, c'est d'un séminaire sur le lâché prise dont vous avez besoin.


## Disjonction simple
L'écriture de la disjonction avec les accolades est une généralisation d'une écriture plus simple,
qui exprime le choix *d'exactement un* des opérandes.

```asp
a;b;c.
```

Lorsque vous lancez clingo là-dessus, vous trouverez trois modèles, un pour chacun de ces trois atomes.
Il est également possible de mettre cette construction dans le head d'une règle :

```asp
b;c:-a.
```

Ici, *b* OU *c* sera vrai si *a* est vrai.

Notez bien que `{a;b;c}` n'est pas égal à `a;b;c` !
Comme expliqué précédemment, les bornes minimales et maximales par défault dans l'écriture avec accolades
sont respectivement zéro et l'infini. Autrement dit, `a;b;c` est équivalent à `1{a;b;c}1`.


## Contraintes
Les contraintes ! On en a souvent parlé,
et certainement brûlez-vous d'impatience à l'idée de les utiliser !

Reprenons un de nos derniers exemples, en ajoutant une contrainte qui écarte
tous les modèles avec une valeur qui n'est pas multiple de 3 :

```asp
% On choisis un nombre entre 1 et 100.
1 { nb(1..100) } 1.

% On écarte tout modèle dont le nombre choisis n'est pas multiple de 3.
:- nb(N) ; N \ 3=0.
```

Premier constat, l'écriture d'une contrainte ressemble à celle d'une règle, à l'exception de la *tête*, qui est vide.
C'est exacement la description d'une contrainte dans la grammaire d'ASP: une règle sans tête.

Cela, logiquement, à un sens : la contrainte est une règle.
Hors, dans une règle, rappelez-vous : lorsque le *corps* est vrai, la *tête* est vraie.

Sauf que, dans le cas de la contrainte, la *tête* est vide : cela veux dire que si le *corps*
est vrai… rien ne peut être vrai !

C'est l'exact sens de la contrainte : si son *corps* est vrai, alors rien n'est vrai.
Il s'agit d'une contradiction fondamentale entre le fait que rien n'est vrai,
et que le *corps* (et probablement d'autres atomes du programme) est vrai.
Par conséquent, le modèle est faux, et ne sera pas considéré par le solveur.

Ici `N\3 = 0` n'est vrai que si `N` est un multiple de 3.
Par conséquent, le *corps* de la contrainte est vrai lorsque nb(X) est vrai avec X un multiple de trois.
Donc le modèle est invalidé dans ce cas.
Donc, sur les 100 modèles précédemment générés, il n'en reste plus que 67:
le nombre de nombres entre 1 et 100 qui ne sont pas multiples de 3.

Un peu de gymnastique intellectuelle est nécessaire quand vous manipulez les contraintes :
elles expriment ce qui doit être faux, pas ce qui doit être vrai.



## Insatisfiabilité
Avec cette histoire de contraintes qui empêchent certains modèles d'exister,
on est en droit de se poser une question… Et si un problème n'est pas satisfiable,
c'est à dire qu'il n'existe pas de réponse ?

Et bien, accrochez vous à vos ceinture, c'est tout à fait possible:

```asp
a.  % a est vrai
:- a.  % a ne peut pas être vrai
```

Ceci est la contradiction la plus simple imaginable. C'est la quintessence même du ridicule, on en viendrait à rire, autant que si les poules avaient des dents, en plus de leur bec !

De son côté, clingo réagit exactement comme il faut:

    clingo version 5.2.1
    Reading from program.lp
    Solving...
    UNSATISFIABLE

    Models       : 0
    Calls        : 1
    Time         : 5.189s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
    CPU Time     : 0.000s

Le problème est bien **insatisfiable**, autrement dit, il n'a aucun answer set, aucune réponse possible.

Un petit mot en passant : si vous avez un jour un problème, que vous arrivez à le modéliser en ASP,
et que vous obtenez une insatisfiabilité, c'est une preuve que votre problème n'est pas soluble.


## Tokens
Petite partie théorique avant d'attaquer un nouveau morceau conceptuel.

Les tokens sont les *morceaux de texte*, les unités minimales qui peuvent être utilisées pour écrire.
C'est un concept théorique assez important, car il peut aider à comprendre mieux le langage dans son ensemble.

En ASP, il existe cinq types de tokens:

- les identifiants: par exemple `a`, `hello_world` ou `a_3_on_y_va`, **mais pas** `A`, `_`, `Arachide` ou `_case` (l'expression régulière est donc `[a-z][a-z0-9A-Z_]*`).
- les variables: un identifiant qui commence par une majuscule ou un underscore (exp. reg: `[A-Z_][a-z0-9A-Z_]*`).
- les nombres: seuls les nombres entiers sont gérés (expreg: `-?[0-9]+`).
- les textes: encadrés par des double-guillemets `"`, ils peuvent contenir n'importe quoi, sauf des double guillemets non précédés d'un antislash (sinon, ça termine le texte).
- les opérateurs: mathématiques (`+ - / * / \ ^ ..`) ou logiques (`; , :- : { }`)

Tout le langage ASP repose sur ces tokens.
Nous verrons qu'il existe un sur-ensemble du langage plus ou moins spécifique à clingo,
qui rentre dans la catégorie de la méta-programmation, mais c'est hors contexte pour le moment.

(C'est la méta-programmation qui nous permettra de *tuner* la recherche de la solution,
par exemple en définissant quels atomes doivent être affichés dans les résultats,
ou définir les valeurs de constantes)

<!-- TODO: un petit mot de la fin ? -->


## ∃ vs ∀
Vous connaissez certainement les deux opérateurs mathématiques suivant :
- ∃: *il existe*, c'est-à-dire *il y en a au moins un*
- ∀: *pour tout*, c'est-à-dire *tous les éléments considérés*

Par exemple *∃ jour de la semaine, je fais la grasse matinée* est vrai : pour moi c'est le dimanche.
Mais je connais des lève-tôt qui se lèvent tôt tous les jours. Pour eux, il faudrait plutôt dire
*∀ jour de la semaine, je ne fais pas la grasse matinée*.

En ASP, ces signes cabalistiques n'apparaissent pas explicitement, mais leur sémantique apparaît visiblement.
Le premier, *il existe*, nous l'avons déjà utilisé : il est implicite dans les *corps* des règles.

Ainsi, dans `a(X):- p(X)`, il est dit que a(X) est vrai si *il existe* un p(X).
C'est particulièrement visible avec la règle `a:- p(X)`.
Ici, il suffit qu'un `p(X)` soit vrai, quelque soit la valeur de X, pour que `a` soit vrai.

D'ailleurs, on pourrait écrire la même règle avec une variable muette pour que ce soit encore plus clair : `a:- p(_).`.

Maintenant que l'on comprend bien que le *il existe* est partout par défaut, attaquons
le *pour tout* avec un exemple complet :

```asp
% J'ai 3 copains dans ma classe
copain(1..3).
% Parfois certains ne viennent pas à la récré
{ en_recre(1..3) } 3.
% On joue au ballon quand on est tous les quatre
on_joue_au_ballon:- en_recre(C): copain(C).
```

Cet exemple génère 8 answer sets, dont un seul contient `on_joue_au_ballon`.

Ici, le corps de la dernière règle implémente
la condition *en_recre(C) doit être vrai __pour tout__ les copains C.*
Autrement dit, si il existe un copain C tel que `en_recre(C)` est faux, alors la condition est brisée,
et le corps de la règle est faux, et par conséquent, on ne joue pas au ballon.

Il est possible d'avoir plusieurs conditions à droite du `:`, et elles doivent être
séparées par une virgule `,` (et non un point-virgule).

<!-- TODO: un petit mot de la fin ? -->


## Erreurs et warnings
Dans l'idéal, une partie entière de ce tuto devrait être écrite justement pour traiter des différentes erreurs,
mais cela requiert un travail supplémentaire qui, selon moi, est très intéressant, ne serais-ce que parce que c'est en général un sujet qui est très peu abordé dans les tutos.
(Si vous lisez cette ligne et que, dans le sommaire et en scrollant un peu, vous voyez que de nombreux cas d'erreurs sont expliqués et traités,
c'est que la phrase précédente n'a pas été retirée depuis leur incorporation ; prévenez-moi !)

### Unsafeness
En codant, il vous arrivera régulièrement de voir clingo lever une erreur du type :

```asp
test.lp:19:1-36: error: unsafe variables in:
  hadoken(Y):-[#inc_base];saiyan(X,Y):gandalf(X).
test.lp:19:9-10: note: 'Y' is unsafe
```

En clair, dans le fichier *test.lp*, ligne *19*, de la colonne *1* à *36*,
clingo n'arrive pas à décider de la valeur de la variable *Y*.
C'est la notion même d'*unsafe* : une variable dont la valeur peut virtuellement être n'importe quoi.

Hors, vous vous en souvenez, on est sensé durant l'étape de grounding avoir la génération des atomes avec toutes les valeurs possibles.
Vous vous doutez que si le nombre de valeur possible sur un atome est infini, on a un problème.

Eh bien, c'est plus ou moins ce que détecte ici clingo : on ne sait pas quoi mettre en valeur de *Y*.

Dans ce cas là, pas d'inquiétude : il suffit de donner un range de valeur.
Dans ce cas précis, on avait le code suivant :
```asp
hadoken(Y):- saiyan(X,Y): gandalf(X).
```
Autrement dit: on a hadoken Y s'il existe un saiyan X Y pour tout gandalf X. Ne cherchez pas la logique dans le lexique, mais plutôt dans la sémantique.
On définit bien X: il s'agit d'une valeur donnée par l'atome gandalf. Mais Y ?
Eh bien, imaginons que `saiyan(X,Y)` soit définit tel que X est une valeur donnée par gandalf/1, et Y une valeur donnée par dumbledore/1.
Dans ce cas, il nous suffit de rajouter une définition pour Y:
```asp
hadoken(Y):- saiyan(X,Y): gandalf(X) ; dumbledore(Y).
```
Et voilà, l'erreur a disparue.


### Syntax error
Celle-là sont en général assez simple à résoudre : il s'agit d'une mésutilisation de la grammaire du langage.

Souvent, lorsque vous avez une telle erreur, c'est que vous avez oublié un point, une parenthèse,…

Comme clingo vous donne l'endroit où est arrivé un *token* inattendu (comme un identifiant à la place d'un point par exemple),
il est assez simple de voir d'où viens l'erreur.
Petit détail : clingo vous donne la localisation du *token* inattendu : cela veut dire que si l'erreur est levée à cause d'un point qui manque,
c'est le token suivant qui sera ciblé.

Donc le code suivant lève bien une erreur :

```asp
atome(avec,arguments,mais,sans,point)
autre_atome(normal,celui,la).
```

Mais clingo vous dira que l'erreur provient de la seconde ligne. C'est normal : de son point de vue,
c'est `autre_atome` qui est en faute, puisqu'il s'agit d'un identifiant qui se trouve près un atome complet,
ce qui n'est pas *attendu* d'après la grammaire du langage ASP.


## Exeeeeerciiiiiiice ! Yodel et papier crépon
Je ne vous le cacherais pas : cet exercice est un poil plus complexe que les précédents, mais ne vous en faites point, vous y arriverez tout pareil.

Voici l'énoncé : on cherche des ensembles de personnes partageant les même goûts,
sachant que l'on sait qui aime quoi via les atomes `aime/2`, tel que `aime("Gérard","Joueur du Grenier")`
signifie que Gérard aime l'émission du [Joueur du Grenier](https://fr.wikipedia.org/wiki/Joueur%20du%20Grenier).

Assez simplement, deux personnes partagent les même goûts si elles aiment une chose en commun.
Il existe au moins deux manières de faire ; voici donc quelques phrases qui pourraient vous aider à trouver
les différentes manières d'attaquer le problème.

- *Il y a au moins deux personnes, au moins un sujet, et tous les atomes aime/2 nécessaires sont vrais*
- *Il y a au moins deux personnes, au moins un sujet, et il n'existe pas de paire personne-sujet tel que aime/2 n'existe pas*
- *Les personnes choisies aiment les sujets choisis, et les sujets choisis sont aimés par les personnes choisies.*


### Les données
```asp
aime("Gérard",("Joueur du Grenier";"Les pois cassés")).
aime("Julie",("Les pois cassés";"Star Wars 9: les siths fantôme contre-retournent l'espoir")).
aime("Marlène",("Les chansons des années 20";"Symballium volume 4";"les roses vertes")).
aime("Michel",("La grande musique (dans le sens de la longueur)";"Star Wars 9: les siths fantôme contre-retournent l'espoir")).
aime("Dominique",("La grande musique (dans le sens de la longueur)";"les roses vertes";"Les poids cassés";"Symballium volume 4")).
```

Avec ces données, vous devriez obtenir 6 modèles. Si vous en obtenez plus, il est possible que certains
des modèles soient des sous-ensembles d'autres modèles. C'est l'effet de bord d'une des deux solutions.


### Aide
Si au bout de 30 minutes, vous:

- **n'avez rien essayé :** bon, au risque de paraître un tantinet habité d'une quelconque passion à propos d'une soupe où nagerait des atomes d'avocats (au sens philosophique, pas physique), j'aimerais vous raconter une petite anecdote, que je connais d'expérience, et qui est assez représentative de l'expérience générale des enseignants dans mon domaine. Il se trouve que, lorsqu'on enseigne, on s'aperçoit assez vite que pas mal d'étudiants (et il se trouve qu'il s'agit majoritairement de filles, moins souvent des gars ; rapport à l'éducation ?) essayent à peine, ou lorsqu'ils essayent, c'est avec un mélange de timidité et de stress ; si bien que, au bout de longues minutes à s'imaginer être incompétents, ils finissent par appeler l'enseignant pour de l'aide. Enseignant qui ne voit qu'un écran blanc, et n'a comme unique information *j'y arrive pas*. Difficile de faire quoique ce soit dans ce contexte, et même impossible si yavais soupe d'avocat à la cantine. Le truc, c'est que ces étudiants ne se lancent pas, craignent l'idée de ne pas réussir du premier coups. Je sais que c'est un problème très commun en info (ça doit arriver ailleurs, certainement), mais je n'ai aucune espèce de piste pour résoudre le problème, à part travailler, en amont, au niveau de l'éducation elle-même. La conséquence de ça, je pense, c'est que ces étudiants ne collectent aucune expérience qui sera plus tard nécessaire à faire un boulot en info (ou un boulot tout courts). Certains arrivent au bout de plusieurs années d'études, et sont toujours incapable de lire ou écrire un quelconque morceau de code. Je n'ose imaginer ce que ça donne après dans un contexte professionnel. Bref, évitez la soupe à l'avocat.
- **n'avez rien essayé, mais c'est parce que votre poisson rouge est mort, votre grand-mère s'est remise à l'haltérophilie, votre ordinateur fait des mises à jour, et il est déjà 24h64 à hawaï :** je comprend, ça doit être dur. Un indice : l'ASP c'est tellement haut niveau, il suffit souvent de traduire les phrases pour avoir un résultat.
- **avez trouvé 18 manières différentes de résoudre le problème, mais toutes nécessitent un microscope électronique à balayage à pile, ou une fusée voyageant à au moins 0.6c :** vous avez peut-être mal compris l'énoncé. Les solutions sont toujours en bas de page, et vous noterez qu'elles ne nécessitent aucun appareillage sophistiqué.



# En pratique !
Maintenant que l'on a les bases, nous allons (enfin !) pouvoir
attaquer de vrais problèmes.

Je suis certain que depuis le temps, vous vous êtes demandés
si tout ceci n'était pas une vaste conspiration pour vous faire perdre votre temps.
Mais ne vous inquiétez pas : il n'y a nul conspiration.

Ici, il ne s'agit pas d'exercice à proprement parler, dans le sens où le but est de lire et comprendre un code existant.
Néanmoins, la définition du problème sera donnée en amont, et par conséquent, vous permet d'essayer de votre côté
avant de regarder le code tout fait.

Je vous conseille évidemment de faire les choses ainsi.

Notez également qu'une *directive de méta-programmation* sera utilisée pour éviter de polluer trop la sortie des solutions : `#show`.
Ne vous inquiétez pas trop à ce propos, il s'agit juste de choisir quels atomes sont affichés en sortie.
Ignorez-le dans un premier temps, triturez le un peu pour comprendre après (le premier exemple s'y prête bien),
et éventuellement allez lire [la partie qui y est consacrée](#show).


## Du bruit dans la cuisine
*Un petit exercice qui me vaudra des lettres de menace de la part de mes amis acousticiens.*

En considérant une maison, composée de diverses pièces (genre, la cuisine, le salon, le placard à balai,…),
dont l'une est la source d'un bruit d'un certain niveau (d'une certaine force, dirons nous).

Question : quelle est le niveau sonore enregistré dans les autres pièces ?

Approximation : disons qu'un niveau sonore est une valeur qui va de 1 à 10,
pour 1 étant *à peine audible* et 10 étant *j'ai mal aux tympans*, et que le niveau baisse de 1 pour chaque pièce traversée.
(pour le dire autrement : pas d'échelle logarithmique, pas de calculs pour les phénomènes de réverbérations/amortissement, que sais-je encore)

Intuitivement, le son ne se propage d'une salle à une autre que si elles sont connectées,
et le niveau sonore enregistré (ce qui nous intéresse) est égal au niveau maximal dans la salle.

### mézon
Voici une manière d'encoder le plan de la maison :

```asp
% connected rooms
next_room(0,9). % la salle 0 est à côté de la salle 9
next_room(7,(0;1;2;3;8;12;13)).
next_room(8,(9;11)).
next_room(10,(9;11)).
next_room(11,(10;12)).
next_room(6,(3;13;5)).
next_room(4,(3;5)).
```

Et maintenant, on dit qu'il y a un son de niveau 10 dans la salle 4:
```asp
sound(4,10).
```

Logiquement, puisque le niveau sonore ne peut que baisser, la salle 4 possède déjà son niveau sonore enregistré : 10.
On notera que, par définition, une salle accessible depuis la 4 aura un niveau sonore de 9.

Vous avez largement ce qu'il faut pour décider de votre approche !


### Calcul de solutions
Voici une solution possible

```asp
% le lien est commutatif : si A est à côté de B, alors B est à côté de A.
next_room(X,Y):- next_room(Y,X).

% Transmission du niveau sonore, avec un offset de -1.
sound(X,Level-1):- sound(Y,Level) ; next_room(X,Y) ; Level >= 0.

% On ne considère que le niveau sonore maximal.
max_sound(X,L):- sound(X,L) ; not sound(X,L2): L2 > L, sound(X,L2).

% N'afficher que les niveaux sonores enregistrés.
#show.
#show max_sound/2.
```



# Placement de table, première approche
Lors d'une fête de famille, ils y a deux problèmes majeurs :

- qui apporte le dessert ?
- qui s'assoie où à table ?

C'est bien entendu le second qui nous intéresse ici.

## Spécification du problème
L'idée est la suivante : nous avons un ensemble de places numérotées,
et des relations entre elles. Par exemple : la place 2 est à côté des places 1 et 3, et en face de la place 9.

Nous avons également des personnes, qui doivent toutes être placée sur une place exactement.

Maintenant, il y a des contraintes. Par exemple :

- Justin ne peut pas être à côté ou en face de Karine, ils ne se supportent pas.
- Mettre Cunégonde et Roger à côté est en revanche conseillé : ensembles ils font rire leur voisin avec leurs histoires de parties de curling.
- Mamie doit être à côté de la cheminée, mais pas Gérard.
- Si Pépé est à côté de Jeanine, alors Xavier doit être de l'autre côté de Jeanine.
- Yolande veut être à la place la plus éloignée de la cuisine, pour éviter d'avoir à y aller.

Bref, le joyeux bordel typique du placement de table d'une réunion de famille.
Eh bien, rassurez-vous : ce calvaire est fini, vous pouvez annoncer à votre famille que désormais c'est vous qui vous en occupez !
Et ça ne vous prendra pas bien longtemps pour tout encoder parfaitement, et placer les étiquettes indiquant les positionnement des gens.
Il ne reste donc plus qu'à vous faire mousser pour *ce placement de table par-fait !*

## Objectif
Avoir pour chaque personne une place qui lui convienne.

Avoir plusieurs modèles/ensembles réponse, chacun décrivant un positionnement possible.


## Pourquoi une première approche
Il est sous-entendu qu'une seconde approche se fera, plus tard.
Effectivement, cette première approche est naïve : elle considère qu'il existe une solution qui satisfasse toutes les contraintes.
Si vous avez une famille avec beaucoup de contraintes, il est possible que le problème soit insatisfiable,
et par conséquent, certaines contraintes doivent être retirées.

Il existe une solution élégante à ce problème, grâce aux directives de méta-programmation, et plus précisément les *optimisations*,
que nous verrons plus tard.

C'est donc dans la deuxième volée d'applications que nous verrons une approche plus maligne qui nous permettra de gérer les familles trop compliquées.
Cela dit, même si votre famille est compliquée, il est possible qu'une solution existe : alors tentez malgré tout, vous pourriez être surpris.







# Métaprogrammation
Métaprogrammation est un mot qui peut faire peur, un peu comme *nombre complexe* en maths, ou *staphilococus* en cours de phylogénie.
Mais en vrai, ça va.

Clingo (gringo) est capable de comprendre un sur-ensemble de l'ASP qui relève de la méta programmation.
Autrement dit, il existe des expressions valides qui ne sont pas de l'ASP, mais qui permettent de manipuler
le grounding ou le solving du programme (c'est donc [méta](https://fr.wikipedia.org/wiki/M%C3%A9ta%20(pr%C3%A9fixe))).

Ces expressions ce nomment *directives de métaprogrammation*, et commencent systématiquement par un `#` (elles sont donc faciles à reconnaître).

Nous allons ici voir les plus utiles. Pour plus d'exhaustivité,
je vous renvoie [au manuel de clingo](http://sourceforge.net/projects/potassco/files/guide/).


## #show
Il s'agit probablement de la directive la plus utilisée : il s'agit de déterminer
quels atomes seront affichés dans la sortie de clingo.

En effet, pour chaque answer set, clingo donne la liste complète des atomes
vrais. Dans certains cas, notamment quand vous avez beaucoup de données et d'atomes intermédiaires,
seuls quelques uns vous intéressent.

Par exemple, si vous codez un solveur de sudoku, les données (les cases déjà remplies)
ne changent pas, sont constantes d'un answer set à l'autre : vous ne voulez pas les afficher.

C'est là que `#show` intervient.

```asp
a(1;2;3).
b(X):- a(X).
#show b/1.
```

En runnant ce programme, avec ou sans la dernière ligne,
vous allez avoir *exactement* 1 modèle/answer set, contenant 3 ou 6 atomes selon les cas.

Pour être plus rigoureux, dans les deux cas les atomes vérifiés dans le modèle sont strictement identiques,
c'est juste qu'avec la dernière ligne, seuls 3 sont affichés (ceux ayant `b` comme prédicat).
**Show change les atomes affichés, pas les answer sets.**

Notez la manière dont on renseigne *l'ensemble des atomes de prédicat `b`*: en utilisant une notation très courante dans le monde de la programmation logique: `<prédicat>/<arité>`.
Si vous remplacez le 1 par un 2, clingo n'affichera rien : il va en effet afficher uniquement les atomes de prédicat `b` avec deux arguments, c'est-à-dire, dans ce cas précis, aucun.


### Le côté obscur de #show
Le programme suivant affiche 4 atomes, et aucun d'entre eux ne fait réellement partis du modèle trouvé par le solveur.

```asp
b(1).
#show b.
#show 23.
#show p(X): b(X).
```

Nous voyons ici trois usages différents de show.
Le premier et le second sont des moyens d'afficher des données, y comprit des nombres.

Le troisième montre qu'il est possible de faire quelques opérations logiques sur les règles à montrer.
Cela peut servir pour filtrer précisément les atomes à afficher, ou pour renommer les atomes
(ici, on renomme `b/1` en `p/1`).

Notez bien que ces usages de *show* sont *génératifs* : ils ajoutent des atomes dans la réponse,
sans les ajouter dans le solving lui-même (essayez en ajoutant `c(X):- p(X).`, vous verrez que c/1 n'est jamais affiché)


### Le #show impératif
Il existe une dernière forme pour cette directive : `#show.`.
Elle se traduit par *n'affique strictement que ce qui est demandé*.

Par exemple, si tous les shows de mon programme sont génératifs (cf section précédente),
comment faire pour n'afficher que ceux-là, et pas le reste du programme ?

```asp
a.
#show 23.
```

Ce programme va afficher dans l'unique modèle les atomes *a* et *23*.
Maintenant, si j'ajoute `#show.` quelque part…

```asp
a.
#show.  % par exemple, ici
#show 23.
```

Paf ! Seul *23* est affiché. Pourquoi ? Parce que *a* n'a pas été explicitement rattaché à un show,
et n'est donc pas affichable.

En général, les directives `#show` se trouvent en fin de fichier (du point de vue de l'humain,
c'est la dernière chose qui est faite), et le premier *show* est généralement `#show.`.
C'est une habitude qu'on retrouve dans beaucoup de codes ASP.


## #const
Comme C utilise `#define` et `const`, clingo utilise un mélange des deux : `#const`.
Là s'arrête le parallèle, et commence un exemple :

```asp
#const ma_constante_avec_un_nom_a_rallonge = 42.
#const m_constnte_sns_l_lettre_ = "a".

a(m_constnte_sns_l_lettre_).
a(ma_constante_sans_la_lettre_b).
p(X):- X=ma_constante_avec_un_nom_a_rallonge.
#show ma_constante_avec_un_nom_a_rallonge.
```

Nous avons ici deux constantes, nommées `ma_constante_avec_un_nom_a_rallonge`
et `m_constnte_sns_l_lettre_`, associées aux valeurs 42 et "a", respectivement.

Le `#const` se comporte comme le `#define` du C: lors du *grounding*,
toute occurence du nom de la constante sera remplacée par sa valeur.

Et tout comme le `#define` en C, il peut être réécrit lors de l'appel au compilateur.
Dans notre cas, lors de l'appel à clingo.

Ainsi, si vous voulez définir la valeur d'une constante lors du lancement du programme,
il suffit d'utiliser l'option `-c` : `clingo -c ma_constante_avec_un_nom_a_rallonge=23`.
Il s'agit donc d'un excellent moyen de proposer une personalisation d'un programme
sans avoir à tripoter le code.

Enfin, notez que tout comme le préprocesseur du C, clingo est malin :

```asp
#const cst = b.
cst(cst).
```

Ce code génère un answer set d'un atome qui est… `cst(b)`,
car __*#const* agit sur les valeurs, pas les prédicats.__


## #minimize et #maximize
Le nerf de la guerre.

Les answer sets trouvés par le solveur ne sont pas toujours égaux :
souvent, l'objectif est de maximiser ou minimizer un score,
et cela permet de trier les bonnes et les mauvaises solutions.

Par exemple, si vous créez un solveur de puzzle, vous allez vouloir préférer
les solutions qui utilisent le moins de ressources (nombre de coups, nombre de pièces,
nombre de je-sais-pas-quoi-que-le-puzzle-utilise-et-qu'on-veut-utiliser-le-moins-ou-le-plus-possible,…).

Dans un autre registre, c'est ce qui nous permettra, dans les prochains exemples,
de trouver le *meilleur* PC selon des contraintes diverses.

En général, à partir du moment où vous cherchez *le plus bidule* ou *le moins machin*,
vous avez besoin d'une minimisation ou maximisation.
(parfois ce ne sera pas nécessaire, mais gardez l'idée à l'esprit)


### Considérations techniques
En soit, ça ne change pas grand chose sur le solving, puisqu'en théorie,
il suffit de générer toutes les réponses, puis les trier selon leur score.

L'inconvénient, c'est qu'il faut (1) énumérer tous les réponses, ce qui n'est pas forcément pratique
(essayez donc de générer et sauvegarder l'ensemble des grilles de sudoku pour voir),
et (2), trouver le maximum là-dedans *a posteriori*, c'est-à-dire sans que l'heuristique du solveur n'ait joué de rôle.

Hors, et c'est bien là tout l'intérêt d'une heuristique faite par des experts :
si on donnait la mesure du score à l'heuristique, elle ne se contenterait pas d'énumérer les réponses possibles et de les triers par score :
elle s'abstiendrait de générer celles qui sont moins bonnes que celles déjà générées.

En d'autre terme, donner à l'heuristique nos préférences en matière de modèle lui permet d'élaguer l'espace de recherche
pour aller plus vite, et se diriger petit à petit vers l'une des meilleure réponse, le *modèle optimal*.


### Syntaxe
La syntaxe est un poil bizarre au début, mais on s'y fait bien.

```asp
1 { nb(1..100) } 2.  % un modèle == un entier
#maximize{N:nb(N)}.  % maximiser l'entier choisi
```

Ici, c'est la deuxième ligne qui fait le travail : on dit à clingo de maximiser N,
pour N le nombre choisi en ligne 1.

Il y a beaucoup de subtilités avec cette syntaxe, essayez par exemple de changer
la borne supérieure de la disjonction par un 2, ou par rien.


### Priorité
Parfois, il y a plusieurs paramètres à minimiser/maximiser.

```asp
1 { nb(1..100) } 1.  % un modèle == un entier
#minimize{N@2:nb(N)}.  % minimiser l'entier choisi (priorité 2)
#maximize{N@1:nb(N)}.  % maximiser l'entier choisi (priorité 1)
```


## #min et #max
Utiles.
## #count
Utile.
## #project
Un détail avec de l'importance.
## #program
Des fichiers dans des fichiers.





# Interface avec Python
ASP s'interface nativement avec Python et Lua. Je ne traite que de Python ici,
mais les principes sont exactement les même avec Lua.

## Embedding dans Python
Plutôt qu'appeler clingo pour tous nos cas de tests, et vérifier à la main si ils fonctionnent correctement,
ou juste si on a besoin d'appeler clingo plusieurs fois avec des traitements des résultats,
il est possible de le faire depuis Python.


### API officielle
Il existe un module officiel, qui est dans les sources du logiciel et que vous pouvez installer avec un `python setup.py install` standard.
Je n'utilise pas cette API en règle générale.


### Autres API
Une alternative est [pyasp](https://github.com/sthiele/pyasp).
Néanmoins, ce package et ne supporte pas clingo *seul*,
mais plutôt gringo et clasp comme deux binaires
séparés appelés séquentiellement.
Hors, dans les nouvelles versions du solveur, seul clingo est distribué.
Pyasp n'est donc (pour le moment) pas une alternative viable pour utiliser les versions les plus récentes.

L'autre alternative, que je vous conseille pour démarrer, est [clyngor](https://github.com/aluriak/clyngor).
C'est un module python on ne peux plus standard, disponible sur pypi,
et qui ne nécessite qu'une chose: que le binaire clingo soit dans votre $PATH.

Et normalement, c'est déjà fait :)


## Extending avec Python
Vous avez déjà étendu Python avec du C pour gagner un peu de performances ?
Eh bien, de la même manière, on peut mettre du Python (ou du Lua) dans ASP
pour profiter, pendant le solving même, de la puissance d'un langage impératif.


### Multi-shot solving
TODO

### Iterative solving
TODO




# Real-world application


## Placement de table, seconde approche
Après [la première approche](#placement-de-table-premire-approche) vient… la seconde approche !



## Golfing
Le *golfing*, en informatique, est un jeu qui consiste à réaliser une tâche avec le moins de commande possibles.
Par exemple, le *vim golfing* consiste à changer un texte donné en un autre texte cible (donné également) en utilisant le moins de commande possibles au sein de l'éditeur vim.
Il existe aussi le *code golf*, qui consiste à faire un programme le plus court possible. C'est ça qui nous intéresse ici.

Si vous ne connaissez pas [codegolf.stackexchange](https://codegolf.stackexchange.com),
il s'agit d'une des instances de stackexchange (la plus connue étant probablement stackoverflow),
où les questions sont des challenges de *code golf*, où des centaines de programmeurs s'amusent à imaginer les programmes les plus courts possible,
dans une multitude de langages différents (parfois créés uniquement pour le *code golf*).
Le score correspond au nombre de caractères dans le code ; le but étant de faire le programme le plus court possible, il faut donc de minimiser ce score.

Nous allons nous intéresser au [**calcul de score du boggle**](https://codegolf.stackexchange.com/questions/143213/score-a-game-of-boggle),
car il est simple et nécessite un peu de python. C'est bon pour l'entraînement.

Nous allons voir qu'il est possible d'atteindre un score certes moins bon que
[python seul](https://codegolf.stackexchange.com/a/143218),
mais meilleur que les langages les plus verbeux comme java.

### Principes
Chaque joueur possède un ensemble de mot uniques d'au moins 3 caractères.
Le score d'un joueur est la somme des valeurs de ses mots.
Un mot trouvé par un autre joueur vaux zéro.
Un mot de 3 ou 4 lettres vaux 1 point. 5 lettres, 2 points, 6 lettres, 3 points, 7 lettres, 5 points,
8 lettres ou plus, 11 points.

### Données
Les données seront encodées avec un prédicat qui associe un numéro de joueur et les mots qu'il a trouvé.
Les contraintes sur les mots nous servent bien : un mot ne peut pas apparaître plus d'une fois pour un joueur.

Suit le premier exemple donné dans la question :

```asp
player(1,("cat";"dog";"bird";"elephant")).  % score: 12
player(2,("bird";"dog";"coyote")).  % score: 3
player(3,("dog";"mouse")).  % score: 2
```

Calculons ensembles le score du joueur 1: *cat* donne 1 point, *dog* et *bird* ont été trouvés par d'autres joueurs et donnent donc 0 point, et *elephant* donne 11, soit un total de 12 points pour le premier joueur. De notre point de vue, cela veux dire que nous devons générer `score(1,12)`.

### Méthodologie

Déjà, nous avons besoin de déterminer quels sont les mots qui compterons pour le score.
Une première solution est de dire que 1 et 1 seul joueur à trouvé le mot.
L'autre solution est que, sachant un joueur l'ayant trouvé, tous les autres ne l'on pas trouvé.

```asp
unique(P,W):- 1 { player(_,W) } 1 ; player(P,W).
unique(P,W):- player(P,W) ; not player(P2,W): player(P2,_) P2!=P.
```

Maintenant que l'on sait quel mots doivent être comptés dans le score pour chaque joueur,
il est temps de se poser la question du score lui-même :

```asp
score(P,S):- S = #sum{L: unique(P,W), value(W,L)} ; player(P,_).
```
L'atome `score(P,S)` associe un joueur et son score final,
obtenu en faisant la somme des valeurs *L* des mots *W* qui sont uniques et associés au joueur.

Le problème de cette approche, c'est la génération automatique de `value(W,L)`.
En effet, en ASP, il n'est pas possible d'obtenir la longeur d'une chaîne.
Par conséquent, nous allons faire un peut de magie avec python:

```asp
#script (python)
def value(word):
    return len(word.string)
#end.
```
Notons que la valeur est facilement calculable en python, en utilisant le snippet utilisé [ici](https://codegolf.stackexchange.com/a/143218):

```asp
#script (python)
def value(word):
    return [1,1,2,3,5,11][min(len(word.string),8)-3]#end.#show s/2.
#end.
```

Et voilà, nous pouvons accéder à la valeur d'un mot W avec `@value(W)`. Que c'est magnifique !
Il serait possible d'encoder le mapping de la taille et de la valeur en ASP ainsi:

```asp
value(3,1).
value(4,1).
value(5,2).
value(6,3).
value(7,5).
n(8..99).
value(X,5):- n(X).
```
Mais l'inconvénient est triple : c'est long, il y a une génération de nombreux atomes inutiles,
et ça oblige à donner une limite supérieure à la taille des mots.

Donc, on garde la fonction python qui fait la totalité du mapping mot -> score,
ce qui nous permet de l'appeler dans la somme, et on obtient le code total suivant :

```asp
unique(P,W):- 1 { player(_,W) } 1 ; player(P,W).
score(P,S):- S = #sum{@value(W): unique(P,W)} ; player(P,_).
#script (python)
def value(word):
    return [1,1,2,3,5,11][min(len(word.string),8)-3]
#end.
```

Wow ! On obtient bien les bons scores pour chaque joueurs :
`score(1,12)`, `score(2,3)` et `score(3,2)`.

Maintenant que le programme fonctionne, il ne reste plus qu'à le *golfer*, et à compter les caractères. Voici donc notre script final, atteignant un score de 137 caractères, ce qui le place avant-avant dernier (devant PHP et Java) au moment où j'ai écrit ce programme :

```asp
u(P,W):-1{p(_,W)}1;p(P,W).s(P,S):-S=#sum{@v(W):u(P,W)};p(P,_).#script(python)
def v(w):return[1,1,2,3,5,11][min(len(w.string),8)-3]#end.
```

Notez que les données d'entrées doivent être encodées avec le prédicat `p` à place de `player`.
Aussi, la directive de script ignore le reste de sa ligne, par conséquent,
faire un one liner parfait est impossible ici.





## Construire un PC
Ici, on va s'intéresser à un jeu de lego : construire une machine.

Cela pourrait vous servir un jour, et sinon, c'est toujours rigolo à faire.
Aussi, nul besoin de vous y connaître en PC, les explications viennent avec.

Ce genre de programme s'organise autour de deux principaux programmes:
celui qui récupère les données, c'est-à-dire les pièces de pc disponibles,
comme par exemple les cartes graphiques, les processeurs, les boîtiers,…
et celui qui construit le pc à partir des pièces récupérées, c'est-à-dire
qui choisi quelles pièces utiliser.

Le mot-clef, vous l'aurez compris, c'est *choisir*, et il se trouve dans la seconde
catégorie. L'interface avec un distributeur de matériel informatique n'est pas
le sujet de ce tuto, donc on s'arrangera avec quelques données faites à la main.

Mais si un jour quelqu'un veux s'amuser, la première étape est tout à fait automatisable,
par exemple en tapant dans l'API d'un distributeur qui en propose une.


### Spécifications
Une machine est un ensemble de plusieurs pièces : CPU, GPU, RAM, carte mère, refroidissement, disque dur, SSD, boite, périphérique.
Chacune de ces *catégories* doit se voir assigner une (et une seule) pièce, ou éventuellement zéro si la catégorie est optionnelle
(par exemple, je peux vouloir un SSD *si possible* ; c'est donc optionnel)

Chaque pièce appartient donc à une catégorie, et possède un prix, des dépendances et des incompatibilités.
Aussi, elles auront chacune une note de *préférence* : je pourrais ainsi dire *je préfère la GPU 1080 à la 1070*
en mettant une plus grande préférence sur la première.

Enfin, et c'est là tout le sel : on ne veux pas dépasser un prix maximum.

### En clair
On veut un programme ASP qui, en considérant les pièces disponibles, nos préférences personnelles, les interdépendances
entre les pièces, et un prix maximum, soit capable de nous donner une bonne solution, voir la meilleure.

Là où ASP est génial, c'est qu'il n'y a pas besoin de connaître grand chose en heuristique pour résoudre ce genre de problème
(qui, j'en suis sûr, se réduit [au problème du sac-à-dos](https://fr.wikipedia.org/wiki/Problème%20du%20sac%20à%20dos), et par conséquent est NP-complet).

Le code le plus récent est disponible sur [le dépôt](https://github.com/aluriak/learning-ASP/blob/master/build-pc.lp).
Nous allons ici l'aborder point par point.


### Commentaires
Nous allons étudier le programme, découpé en 5 parties.
Les premières parties sont de la pure description,
nous allons donc nous contenter de décrire des faits,
comme par exemple *cette GPU est trop cool*,
ou *ce composant est incompatible avec celui-là*.

Les dernières parties vont implémenter le moteur réel, la partie du programme
qui va utiliser les faits pour en déduire une configuration valide d'ordinateur.
C'est ici que nous trouverons les contraintes et les directives de maximisation.


#### Données
Tout d'abord, nous déclarons les données que nous allons utiliser,
c'est-à-dire les pièces disponibles, pour chaque catégories, avec leur nom et leur score (qui représente à quel point la pièce nous intéresse).

```asp
component(gpu,"A",330,10).
```

Ici, le composant de catégorie GPU, sobrement nommé *A*, coûte 330€ et est noté 10/10,
autrement dit, cette GPU, c'est notre préférée.

Les deux autres GPU accessibles sont données avec les trois lignes suivantes.

```asp
component(gpu,"B",200,7).
component(gpu,"embedded graphic chipset",0,4).
require(gpu,"embedded graphic chipset",cpu,"C").
```

Les deux autres GPU étant moins bonnes, leurs prix et notes sont moins hauts (voir nuls pour la *C*, mais il s'agit d'une puce graphique intel, ce n'est donc qu'une solution par défaut).

##### Dépendances
Notez l'atome `require/4` qui nous permet de définir que la puce intégrée
nécessite le CPU *C*, et par conséquent (et la règle qui s'en assure sera vue plus tard)
que le choix de cette GPU oblige à utiliser le processeur qui l'embarque (c'est assez logique, finalement).

Néanmoins, si on choisi le cpu *C*, nous ne sommes pas obligés de choisir la puce intégrée,
laissant le champs libre pour une autre carte graphique plus puissante.
(la logique étant que la puce intégrée ne prend pas l'emplacement de la carte graphique, c'est juste un module du processeur ; personnellement mon processeur possède une puce intégrée, mais je ne l'ai jamais utilisée, j'ai une vrai carte graphique à la place)

##### Les autres composants
CPU, RAM, SSD, HDD,… Tous vont passer dans la grande moulinette de l'ASP.
Je vous invite à regarder le code pour avoir une idée de toutes les pièces qui seront utilisées.




#### Préférences
Les choix concernant le build : pièces optionelles, importances relatives.
#### Connaissances du domaine
Pas très utilisé pour le moment, mais donne un exemple simple de ce qui pourrait y être placé.
#### Expansion des données
De l'interface haut niveau aux atomes pour la couche d'en dessous.
#### Modèle
C'est ici que le principal se passe.



### Aller plus loin
#### Attrapez les toutes
Déjà, une première étape, c'est effectivement de récupérer les données.
Évidemment, récupérer TOUTES les pièces possibles est un peu long,
alors avoir des informations en amont, notamment les prix minimaux et maximaux (globaux, et par catégorie)
permet déjà d'élaguer. En général, toute limitation est bonne à prendre : taille de la RAM, du stockage, nombre de cœurs…

Tout cela est facile à intégrer dans le programme ASP : il ne s'agit que de rajouter des pièces,
des préférences, voir des contraintes.

Une solution pourrait être de parser ou chopper l'API d'un site de vente
de matériel, par exemple [LDLC](https://www.ldlc.com/configurateur-pc/)
ou [partpicker](https://pcpartpicker.com/).


#### Dans le ¬Sephiroth
Une fois que les deux premières parties sont mises en place et travaillent ensembles,
vient l'étape de distribution.

Une manière de faire, c'est une interface web, où les utilisateurs peuvent checker
les pièces disponibles qui les intéressent, éventuellement faire un peu d'apprentissage pour proposer
des pièces intéressantes (si 80% des utilisateurs qui prennent 8Go de RAM choissisent aussi une 1080,
alors automatiquement proposer une 1080 à tout utilisateur qui prend 8Go de RAM).

La deuxième étape, c'est de constituer la base de donnée et de préférence de l'utilisateur
en fonction des composants qu'il a choisi et des indications qu'il a donnée.

Enfin, il faut faire tourner le solveur
([dans le navigateur du client](https://github.com/aluriak/webclingo-example)
grâce à du [webassembly](https://fr.wikipedia.org/wiki/WebAssembly)
parce que nous vivons déjà dans le futur),
et de sortir les meilleurs *build* au client.

Et paf, vous vous faites connaître, [r/buildapc](https://www.reddit.com/r/buildapc/)
devient votre source d'utilisateur principale,
et vous devenez riche grâce à un système comme [*coinhive*](https://coinhive.com),
qui bien sûr, dans le futur, est bien plus mature, éthique, démocratisé,
et contrôlable par l'utilisateur final.



## Résoudre un donjon de The Legend of Zelda
### Contexte
Dans sa franchement intéressante série [*Boss Keys*](https://www.youtube.com/watch?v=ouO1R6vFDBo&list=PLc38fcMFcV_ul4D6OChdWhsNsYY3NA5B2),
Mark Brown, un designer professionnel dans le milieu du jeu vidéo, cherche, épisode par épisode, à comprendre la structure interne et les logiques
qui sous-tendent les donjons des jeux de la licence [The Legend of Zelda](https://fr.wikipedia.org/wiki/The%20Legend%20of%20Zelda%20(s%C3%A9rie)).

Si vous aimez cette série de jeu, ou le game design en général,
je ne peut que trop vous conseiller *Boss Keys*, et plus généralement son excellente chaîne,
[*Game Makers Toolkit*](https://www.youtube.com/channel/UCqJ-Xo29CKyLTjn6z2XwYAw).

Lorsqu'on regarde *Boss Keys*, au fur et à mesure des épisodes on s'aperçoit que Mark Brown
imagine, formalise et améliore, vidéo après vidéo, un langage qui lui permet de définir formellement les donjons des jeux.
Dans les derniers épisodes, le langage devient vraiment complet et descriptif.

Sans surprise, le langage est un [graphe](https://fr.wikipedia.org/wiki/Graphe%20orient%C3%A9), qui donne des informations précises sur la répartition dans l'espace et le temps
des objets et mécanismes qui constituent les donjons, et permet à Mark Brown de délimiter la *solution* du donjon,
c'est-à-dire la succession d'actions à opérer qui permettent, à la fin, d'ouvrir la porte du *boss* avec la clef dédiée
(d'où le nom de la série, *boss keys*).


### Notre boulot
En lisant les lignes précédentes, une idée vous est venue : si nous avons accès à une représentation formelle des donjons du jeu,
et que nous pouvons formellement décrire les actions et les buts, alors il serait possible d'écrire un programme qui,
comprenant le langage de description de Mark Brown, serais capable de décider d'une solution au donjon.

Bien sûr, vous vous doutez que si j'en parle ici, c'est parce que nous allons nous y intéresser avec ASP.

Voici une image piquée de la vidéo [*The Legend of Zelda: A Link Between Worlds' dungeon design | Boss Keys*](https://www.youtube.com/watch?v=E7sm-0nGV34) :

<center>{% img {filename}/images/asp/zelda_mark_brown_dungeon.png 700 "Zelda dungeon representation by Mark Brown" %}</center>

On voit bien le départ, la fin (*boss*, en bas), et les différentes étapes qui mène à la résolution du donjon.
On comprend bien ici qu'une solution au donjon est un parcours de ce graphe qui part du départ et arrive au boss
en ne passant par les obstacles que lorsque la clef ou l'outils associé est possédé.


### Modélisation
Petit rappel sur le langage développé par Mark Brown, i.e. la représentation en graphes des donjons :

- les nœuds sont des salles, ou zones du donjon portant un objet d'intérêt.
- deux nœuds sont reliés si il existe un passage entre les deux.
- un objet d'intérêt est soit un obstacle, soit un objet à ramasser.
- un obstacle ne peut être contourné/annulé que par un objet.
- un objet à ramasser est sois un outils, soit une clef.
- une clef est à usage unique, mais ouvre n'importe quel obstacle qui attend une clef.
- un outil est soit la clef du boss, qui permet d'ouvrir la porte du boss, soit un objet de l'univers du jeu (grapping, arc, bottes,…).

Donc, en clair : il faut ramasser une clef pour pouvoir annuler un obstacle qui nécessite une clef (une porte verrouillée, donc),
ou dans le cas des autres obstacles l'objet associé à l'obstacle
(pour annuler un obstacle de type *arc*, il faut que l'objet *arc* ait été ramassé auparavant).

Notez que le graphe n'est pas orienté. Néanmoins, on peut imaginer l'intérêt de l'orientation :
des passages ne pouvant être pratiqués que dans un seul sens par le personnage
(porte de sortie, toboggan,…).

Notez également que le langage est en fait un poil plus complexe, car il a une composante graphique importante
(le placement des nœuds dépends de l'ordre dans lequel les objets/obstacles doivent être traités).
Nous allons néanmoins ignorer cela, car (1) tout le sel est de laisser l'ordinateur faire la résolution totale,
et (2) l'information de l'ordre est redondante, et n'est là que pour faciliter la lecture pour les humains qui regardent la vidéo/l'image.


### Le code
D'abord, la définition du donjon.

```asp
% Dungeon objects.
% onedoor(g).
keydoor(g).
keydoor(b;f).
% door(D):- onedoor(D).
door(D):- keydoor(D).
key(c;e).
% one(d).
key(d).
open(start).  % links starts the dungeon

% Links between doors
link(start,(b;c;d)).
link(b,(e;f)).
link(f,g;g,stop).
```

Et ensuite, la définition de la solution :

```asp
% Doors next to open doors are accessible
accessible(Door):- link(Open,Door) ; open(Open).

% Doors with objects inside are opened freely.
open(ObjDoor):- accessible(ObjDoor) ; key(ObjDoor).
open(ObjDoor):- accessible(ObjDoor) ; oner(ObjDoor).

% Doors that are opened using one non-used key.
open(KeyDoor,Key):- accessible(KeyDoor) ; keydoor(KeyDoor) ; open(Key) ; key(Key) ;
                    not open(KeyDoor,OtherKey): key(OtherKey), OtherKey!=Key ;
                    not open(OtherDoor,Key): keydoor(OtherDoor), OtherDoor!=KeyDoor.

% Doors that are opened using a reusable object.
% open(OneDoor,One):- not open(OneDoor) ; accessible(OneDoor) ; open(One) ; one(One).
% open(TwoDoor,Two):- not open(TwoDoor) ; accessible(TwoDoor) ; open(Two) ; two(Two).

% Keep in mind which object opened which door.
open(Door):- open(Door,_).


#show.
#show open/2.
```



# Liens
## Autres applications
- [ASP for FCA](https://github.com/Aluriak/ASP-for-FCA) un ensemble de programmes qui utilisent ASP pour exprimer des concepts (*pun intended*) de l'[Analyse de Concepts Formels](https://fr.wikipedia.org/wiki/Analyse%20de%20concepts%20formels).
- [une page](http://www.hakank.org/answer%20set%20programming) très complète avec beaucoup d'exemples et de programmes avec explications.
- Au sein [du projet pygarden](https://github.com/IndexErrorCoders/pygarden), [solasp](https://github.com/IndexErrorCoders/pygarden#solasp) est un code ASP qui permet d'optimiser le placement de plantes dans le jardin sachant leurs préférences de voisinage.


## And now, for something totally different
- Tuto/howto pour [utiliser clingo en javascript, côté client](https://github.com/aluriak/webclingo-example).
- N'hésitez pas à poser des questions sur ASP sur [stack-overflow](http://stackoverflow.com/questions/tagged/answer-set-programming).
- la page [potassco/teaching](https://potassco.org/teaching/) regorge de liens.
- une erreur ? une idée ? une question ? Ça se passe sur [le dépôt du blog](https://github.com/aluriak/blog-content).
- If you want to help for the english version, it's [here](https://github.com/aluriak/blog-content/blob/master/articles/tuto-asp%20en.mkd).




# Solutions au exercices
### Notation
`k/3`, `coucou/0` et symballium/10.
### Tel père, tel fils
```
enfant(Enfant,Papa):- papa(Papa,Enfant).
```

### Mon papa c'est le meilleur
```
papa(P):- papa(P,_).`
1 { meilleur_papa(P): papa(P) } 1.
```

### Yodel et papier crépon
Une première solution, qui génère aussi les sous-ensembles de solutions :
```asp
2 {peoples(X): aime(X,_) }.
2 {subject(Y): aime(_,Y) }.
:- not aime(X,Y) ; peoples(X) ; subject(Y).
```

Pour éviter les sous-ensembles, une solution est d'obliger un sujet aimé de toutes les personnes d'être membre de la solution :
```asp
subject(Y):- aime(X,Y): peoples(X) ; aime(_,Y).
```

Vous remarquez que le code ressemble alors à la seconde solution, qui est en fait beaucoup plus simple :
```asp
peoples(X):- aime(X,_) ; aime(X,Y): subject(Y).
subject(Y):- aime(_,Y) ; aime(X,Y): peoples(X).
:- 2>{peoples(_)}.  % au moins deux personnes
:- 1>{subject(_)}.  % au moins 1 sujet
```


*[ASP]: Answer Set Programming
*[answer set]: Un ensemble réponse, un modèle valide contenant un ensemble d'atomes qui sont tous vrais
*[answer set]: Un ensemble réponse, un modèle valide contenant un ensemble d'atomes qui sont tous vrais
*[CPU]: Computing Processing Unit, le processeur.
*[GPU]: Graphical Processing Unit, la carte graphique.
*[RAM]: Random Access Memory, la mémoire vive.
*[POO]: Programmation Orientée Objet, un paradigme où les concepts sont séparés et doivent interagir par envoie de messages
*[PF]: Programmation Fonctionnelle, un paradigme où les fonctions sont manipulées au même titre que les types de base
