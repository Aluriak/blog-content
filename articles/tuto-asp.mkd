Title: Introduction à Answer Set Programming (ASP)
Date: 2017-03-31
Modified: 2017-03-31
Tags: asp, language, tuto
Authors: Lucas Bourneuf
Summary: un tuto pour ASP
Slug: tuto-asp
Lang: français
Translation: false
Status: draft


[TOC]


# Introduction

Cet article est un tuto sur [Answer Set Programming](https://en.wikipedia.org/wiki/Answer%20set%20programming),
un langage de programmation déclaratif implémentant la PPC,
ou *Programmation Par Contrainte* (comme java implémente la POO et haskell la PF).

Pour ceux qui connaissent, il fera certainement penser à [Prolog](http://www.learnprolognow.org/),
puisque ces deux langages reposent sur les même concepts, bien qu'il ne l'implémentent pas de la même manière.

L'objectif n'est pas seulement d'apprendre les bases en faisant joujou,
mais de développer des programmes qui résolvent des problèmes de la vie réelle,
éventuellement avec quelques lignes en plus pour pouvoir réellement l'utiliser dans la vie de tous les jours.



## Quelques liens préliminaires
Comme je passerais très vite sur les *bases*, je conseille une lecture d'un tuto existant.
Pour être franc, je n'ai trouvé que [celui-ci](https://cjamcl.com/blog/a-gentle-introduction-to-asp/) (en anglais),
qui passe aussi très vite sur les bases.

Les scripts ASP utilisés ici sont disponibles
sur le dépôt git [learning-ASP](https://github.com/Aluriak/learning-ASP).

Notez aussi que clingo, le groundeur/solveur que nous allons utiliser,
est accompagné [d'un manuel bien fournis](http://sourceforge.net/projects/potassco/files/guide/),
d'un [nombre impressionnant d'exemples de tous types dans ses sources](https://github.com/potassco/clingo/tree/master/examples)
(j'insiste ; faites y un tour, il y a un exemple pour presque toute les fonctionalités du solveur),
et [d'une mailing list active](https://sourceforge.net/p/potassco/mailman/potassco-users/)
où beaucoup de questions intéressantes sont posées.
(il y a [une autre mailing list](https://lists.sourceforge.net/lists/listinfo/potassco-announce)
pour les annonces des développeurs)


# Concepts généraux
## Principes de Programmation Déclarative
Comment collecter tous les entiers positifs inférieurs à 100 et multiples de 3 ?
En python, une manière de faire est la suivante :

```python
for nb in range(0, 100):
    if nb % 3 == 0:
        print(nb)
```

Ce qu'il y a à voir ici, c'est que l'on *explique* au programme exécutant le code (l'interpréteur python)
comment arriver à la solution qui nous intéresse.
Ce paradigme, dit *impératif*, consiste à expliquer **comment calculer la solution**.

C'est une approche qui est en fait assez peu naturelle, et ça se voit quand on commence la programmation.
C'est effectivement assez consternant de devoir s'expliquer auprès d'un ordinateur qui semble avoir
les capacités de compréhension d'un enfant de 5 ans (8, quand on utilise un langage haut-niveau),
et c'est un gros problème dans l'enseignement en informatique.

La programmation déclarative aborde le problème d'un angle différent :
l'humain ne doit plus expliquer **comment** atteindre la solution,
mais plutôt la **décrire** ,
c'est à dire répondre au **quoi**, ce qui est beaucoup plus naturel pour un humain.
Le paradigme *déclaratif* consiste en l'explication du **quoi**.

HTML est un bon exemple de langage déclaratif: on décrit bien la solution (la structure finale de la page web).
Le HTML n'est pas un langage impératif ; d'ailleurs, si la page finale dépend de paramètres extérieurs (compte enregistré par exemple),
vous ne pouvez plus compter que sur le HTML. C'est généralement là qu'interviennent Javascript, PHP, Python, Java,…
Des langages impératifs qui permettent
de générer du HTML à partir de templates et des paramètres extérieurs.

Sans ces languages, il faudrait avoir en mémoire toutes les solutions possibles,
ce qui n'est pas pratique.


## Principes de Programmation Logique
Le paradigme logique est un sous-ensemble du paradigme déclaratif.
Autrement dit, un langage *logique* est un langage *déclaratif*.
À l'inverse, comme le HTML, un langage *déclaratif* n'est pas nécessairement *logique*.

Le paradigme logique repose sur les méthodes formelles issues des maths
et de la théorie de la logique.
C'est avec ces outils que la description de la solution (la réponse au **quoi**) est formulée.

C'est précisément à cette catégorie de langage qu'ASP appartient.

Pour présenter un peu le concept de la programmation logique,
imaginons un langage qui nous permettrais d'expliquer ce qu'est la solution au programme python vu précédemment (calculer les nombres entre 1 et 100 qui sont multiples de 3) :

```
x tel que : x est un entier, 1 < x < 100, x est un multiple de 3.
```

C'est compréhensible, simple et efficace ; c'est de la programmation logique !
Ce langage précis n'est pas implémenté (et ASP est un peu moins haut niveau que cela),
certes, mais il s'agit d'un exemple d'approche d'un langage expressif.
On remarque bien ici qu'il ne s'agit finalement que de *décrire* la solution.

La [page wikipédia en français sur la programmation déclarative](https://fr.wikipedia.org/wiki/Programmation%20d%C3%A9clarative)
est courte, mais suffisante pour notre étude.


## Principes de Programmation Par Contrainte
Nous pouvons définir une *contrainte* comme *une restriction sur les solutions*.
En d'autres termes, la programmation par contrainte consiste à ajouter des expressions qui écartent des solutions,
qui sinon seraient autorisées.

C'est un moyen efficace de s'assurer qu'une propriété est respectée dans tous les modèles.
«*Deux joueurs ne peuvent démarrer à une distance de moins de 5 mètres*» pourrait dire un designer de jeu.
«*Un taxon ne peut appartenir à deux branches*» dira le phylogénéticien.
«*Je ne peux pas mettre deux packs de lait sur le support arrière du caddie*» dis-je pendant mes courses.

Bref, il est souvent plus simple (et moins coûteux) d'exprimer une contrainte plutôt qu'inclure
cette restriction dans la génération du modèle lui-même.

En général, un langage autorisant la programmation par contrainte pourra être divisé en deux parties :

1. définir les possibles solutions (modélisation de l'espace de recherche)
2. interdire les résultats qui ne nous intéressent pas (contraintes)

La première partie, c'est la *génération*, où l'on génère les candidats pour la solution.
Comme en général ces candidats ne sont pas tous bons, on besoin de les filtrer,
d'où la seconde étape, *l'application de contraintes*,
qui permet de définir quels candidats seront écartés.

Answer Set Programming est un langage logique où les contraintes
font partie du langage autant que le reste des déclarations.
Néanmoins, la dichotomie entre génération et contraintes se voit dans beaucoup de codes ASP,
car les développeurs ont intuitivement ce découpage dans leur réflexions.



# Outillage
Il existe [de nombreuses implémentations d'ASP](https://en.wikipedia.org/wiki/Answer_set_programming#Comparison_of_implementations),
chacunes avec des approches unique
et intéressantes pour résoudre des problèmes plus ou moins spécifiques.

Pour ce tuto, nous allons utiliser la suite [Potassco](https://potassco.org), un ensemble de logiciels
qui gravitent autour d'une idée : implémenter et utiliser ASP.
Plus particulièrement, nous allons utiliser *clingo*.

(si ça vous motive, prenez une autre implémentation ; en général les différences d'utilisation ne seront pas monstrueuses)


## Clingo, en deux cents mots

Clingo est à ASP ce que CPython est à Python:
une usine à gaz qui comprend et applique les effets de bord du langage.
<!-- Faut vraiment que je fasse un article sur ces notions -->

Clingo est en fait constitué de deux composantes: *gringo* et *clasp*.
(que l'on peut récupérer et utiliser à part)

Gringo est à ASP ce que [le compilateur de CPython](https://docs.python.org/3/library/dis.html) est à Python, ou ce que gcc est à C:
une grammaire et un ensemble de routines
qui compilent vers un langage simplifié à l'extrême.
(dans le cas d'ASP, c'est du …, pour CPython c'est le bytecode, et pour C c'est l'assembleur)

Clasp est à ASP ce que l'interpréteur de CPython est à Python:
un ensembles de routines qui pigent le langage simplifié calculé par l'outils précédent (gringo/compilateur)
et en appliquent les effets de bord (mémoire et calculs).

Pour être plus précis à propos de gringo et clasp, le premier compile un programme
qui suit la grammaire d'Answer Set Programming (et un peu plus, nous verrons cela),
et le second est une routine qui, à l'aide d'une heuristique très personnalisable,
va chercher les solutions acceptables dans le programme compilé.

En ASP, on parle de *grounding* pour la partie assurée par *gringo*,
et de *solving* pour la partie assurée par *clasp*.
Clingo est donc un programme qui se charge du grounding et du solving
d'un seul coups.


## Installation
Clingo est disponible sur le [dépôt github](https://github.com/potassco/clingo/)
et sur [sourceforge](http://potassco.sourceforge.net/).
Le premier est aujourd'hui le site de référence.
Plus d'informations sur [le site de Potassco lui-même](https://potassco.org/doc/start/)

À l'écriture de ce tuto, la version de clingo la plus récente est la 5.2.1.
Il est aussi possible, pour de petites instances,
de [faire tourner clingo dans un navigateur](https://potassco.org/clingo/run/).

### Installation manuelle
A moins que vous ne soyez concerné par l'un des quelques OS qui ont un packaging,
le plus simple est probablement de

1. Télécharger ou compiler le binaire *clingo*
2. Le mettre dans le PATH (`/usr/bin` pour les bourrins, `~/.local/bin/` pour les moins bourrins)

*Qu'est-ce que le PATH ?*
[Pour les windowsiens](http://sametmax.com/ajouter-un-chemin-a-la-variable-denvironnement-path-sous-windows/),
[pour les unxiens](http://generation-linux.fr/index.php?post/2008/10/15/Changer-les-dossiers-par-defaut-dans-le-PATH).

Personnellement, j'ai un répertoire `~/bin/` vers lequel mon PATH pointe. C'est ici que j'y ai mis
mes binaires clingo:

```
❯ ls -lA ~/bin | cut -c 50- | grep clingo
clingo521
clingo454
clingo -> clingo521
```

(clingo est un lien symbolique vers l'une des versions installée… généralement la plus récente)
<!-- [comme pour les binaires python]({filename}/articles/the-python-ecosystem.mkd) -->

### Compilation
La compilation de clingo depuis les source est possible,
et conseillée si vous voulez une version particulière avec le support de python
ou de lua avec une version particulière (je pense à python 3, notamment)


```makefile
all: update_repo compile install

install:
	cp clingo/bin/clingo ~/bin/clingo_compiled_from_repo

compile:
	cd clingo && cmake -H. -B.  -DCMAKE_BUILD_TYPE=Release -DPYTHON_LIBRARY:FILEPATH=/usr/lib64/libpython3.5m.so -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.5m -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.5m
	cd clingo && make
	cd clingo && cmake --target test -H. -B.  -DCMAKE_BUILD_TYPE=Release -DPYTHON_LIBRARY:FILEPATH=/usr/lib64/libpython3.5m.so -DPYTHON_INCLUDE_DIR:PATH=/usr/include/python3.5m -DPYTHON_EXECUTABLE:FILEPATH=/usr/bin/python3.5m
	cd clingo/app/clingo/tests && python3.5m run.py --clingo ../../../bin/clingo run

update_repo:
	cd clingo && git pull
	cd clingo && git submodule update --init --recursive
```


## Quelques tests préliminaires
Maintenant que vous avez bien installé clingo, effectuons quelques
tests préliminaires pour étudier un peu l'environnement.

### Version
Pour avoir la versions de clingo, il suffit de demander: `clingo --version`.
Vous verrez quelque chose du style:

    clingo version 5.2.1
    Address model: 64-bit

    libgringo version 5.2.1
    Configuration: with Python 3.6.2, with Lua 5.3.4

    libclasp version 3.3.2 (libpotassco version 1.0.0)
    Configuration: WITH_THREADS=1
    Copyright (C) Benjamin Kaufmann

    License: The MIT License <https://opensource.org/licenses/MIT>

On peut, notamment, voir les versions de gringo et clasp utilisées,
ainsi que les supports de langages de scripts (ici python et lua sont supportés tous les deux).


### Le «bytecode» d'ASP
Il est possible de voir la sortie de gringo avec l'option `--text`. Avec ce flag,
clasp ne sera pas appelé et ne sera retourné que le code simplifié issu du grounding.

Lorsque l'on utilise ASP pour un problème combinatoire, il arrive souvent que l'on
s'intéresse au grounding du programme.
C'est en effet en étudiant ce code intermédiaire qu'il sera possible de déterminer
quelles règles en ASP génèrent beaucoup de données,
et donc quelles règles sont impliquées dans un temps de solving long.


## Lancez la machine !
Lancez clingo sur les fichiers contenant les programmes de ce tuto, ou lancez le sans fichier en argument,
et tapez directement le programme, puis contrôle-D (fin de fichier).
Clingo vous répondra en fonction.

Prenez **vraiment** l'habitude de lancer les programmes, et de les trifouiller.
C'est comme ça qu'on apprend !

Pour bien montrer comment clingo s'utilise, voici
une session complète où j'écris un programme ASP
dans le fichier `program.lp`, puis lance clingo dessus:

    ❯ echo "a.b." > program.lp
    ❯ clingo -n 0 program.lp
    clingo version 5.2.1
    Reading from program.lp
    Solving...
    Answer: 1
    a b
    SATISFIABLE

    Models       : 1
    Calls        : 1
    Time         : 0.000s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
    CPU Time     : 0.000s

Du point de vue de clingo, que se passe-t-il ici ?

- d'abord, clingo parse les arguments de la ligne de commande (ici `-n 0` et `program.lp`)
- il apprend que je veux *tous* les modèles, toutes les réponses possibles (`-n 0`)
- il apprend également que le programme est intégralement contenu dans `program.lp`
- il lance gringo sur le programme, et obtient le code groundé.
- il lance clasp sur le code groundé, et m'affiche le résultat
- j'apprend que mon programme n'a qu'une seule et unique solution, où les atomes a et b sont vrais.

Notez que la ligne `Reading from program.lp` correspond au grounding, et la suivante, `Solving...`, correspond au solving.
Si clingo semble ne rien faire après avoir écrit la première, c'est que le grounding est long (et le pc ne fait pas *rien* ;
vous avez probablement un CPU qui tourne à 100% pendant toute la durée du grounding).

Dans l'autre cas, c'est le solveur qui pédale dans la semoule.



# Principes d'Answer Set Programming
Maintenant que l'on a plein de théorie dans la tête et clingo sur le pc,
attaquons le vif du sujet: parler ASP !

## Commentaires
Les commentaires commencent par un `%`:

```asp
% Je suis un commentaire
Je ne suis pas un commentaire  % ni de l'ASP valide d'ailleurs
```

Les commentaires multilignes commencent avec `%*` et terminent avec `*%`.
Notez que clingo n'est pas capable de gérer la présence d'un `%*`
dans un commentaire multiligne, ni ne considère ce qu'il y a après un `%`,
empêchant d'utiliser le snippet `% *%` comme le `//*/` en C.


## Les atomes
Un atome est un fait, une relation qui est considérée vraie.
Par défaut, tout atome est considéré faux, jusqu'à ce
qu'il soit explicitement statué comme vrai.

Un programme ASP repose sur ce principe,
si bien que la solution à un problème est en fait décrite
par les atomes vérifiés.

Tout le jeu d'un programme ASP est de définir quels atomes doivent être vrais,
sous quelles conditions (c'est la modélisation du problème),
et quelles combinaisons d'atomes rendent une réponse caduque (c'est le job des contraintes).

Considérons le programme suivant:

```asp
a.
```

Ici, on indique que le *fait* `a` est vrai.
À l'inverse, tout autre fait est faux, et si on lance clingo sur ce programme,
nous ne trouverons qu'un seul et unique modèle : celui où a est vrai.

Le point `.` est un peu comme le point-virgule en C,
ou le saut de ligne en Python : il sépare chaque règle et atome du programme.

```asp
a(4).
```

Cette déclaration est un peu plus complexe, mais revient au même : le prédicat `a` d'arité 1
(c'est-à-dire avec 1 argument) avec comme premier (et unique) argument 4, est vrai.

De la même manière, il est possible de déclarer `b`, `b(42)`, mais aussi `a(b)`, `a(a,b,c,3)`, `a(b(1))`, ou encore `a(a(b(b(9))))`.
Le nombre d'argument est virtuellement infinie, et un atome peut être argument d'un autre.


## Retour sur les atomes
Ci-après, un autre programme qui génère des atomes
(donc, des *faits*, des éléments considérés vrais pendant le solving).

```asp
% Les atomes nb(X) sont vrais pour tout X positif inférieur à 100.
nb(1..99).
% Les atomes nb_ex(X) sont vrais pour tout X ∈ [1;4]
nb_ex(1;2;3;4).
% On peut aussi combiner les deux:
nb_cb(1;2;3..10).
```

Donnez ce programme directement à manger à clingo !
Vous comprendrez vite comment ça fonctionne.


## Règles
Maintenant que l'on peut déclarer des faits, nous pouvons commencer à déclarer
des règles de causalité.
En d'autres termes, il est possible de définir qu'un atome est vrai
en se basant sur des conditions.

En ASP, cela se fait avec l'opérateur `:-`, une espèce de `if` à l'envers:

```asp
% l'atome ok(X) est vrai si a(X) est vrai
ok(X):- a(X).
% L'atome nb_3(X) est vrai pour tout X positif inférieur à 100 et multiple de 3.
nb_3(X) :- 0 < X ; X < 100 ; X \ 3 = 0.
```

On appelle la partie *avant* le `:-` la *tête* (head),
et la partie à droite le *corps*.
La tête est vraie si et uniquement si le corps est vrai.

Les règles sont les premiers éléments utiles dans un programme ASP.
Ce sont ces règles qui vont permettre d'exprimer des implications,
et donc de réellement commencer à travailler sur les atomes existants.

Donc, dans un programme ASP, vous avez des atomes considérés vrais (souvent, ce sont des données du problème),
et des ensembles de règles qui vont permettrent d'inférer la véracité d'autres atomes.

Notez qu'il est possible d'utiliser la négation:

```asp
% l'atome ko(X) est vrai pour tout X de nb_ex(X) qui n'est pas ok(X)
ko(X):- nb_ex(X) ; not ok(X).
```

Notez que le point-virgule est utilisé comme opérateur *et*, l'équivalent de `and` en Python ou `&&` en C.
Il n'existe pas réellement de *ou* en ASP ; c'est un détail qui reviendra plus tard.

Une autre manière de voir cette règle, plus verbeuse mais plus puissante, est la suivante:
*Pour tout X tel que nb_ex(X) est vrai et ok(X) est faux, on a ko(X)*.

Cette formulation nous permettra de mieux comprendre une prochaine construction du langage.


## Disjonction (choix)
Une construction très importante en ASP est le *choix*.
Le choix consiste en un… choix. C'est dur à expliquer autrement.

Voici un exemple simple, avec le résultat donné par clingo,
qui consiste en un choix de exactement 1 parmis 3 atomes :

```
❯ echo "1{a;b;c}1." | clingo -n 0
clingo version 5.2.1
Reading from stdin
Solving...
Answer: 1
b
Answer: 2
c
Answer: 3
a
SATISFIABLE

Models       : 3
Calls        : 1
Time         : 0.000s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
CPU Time     : 0.000s
```

La sortie de clingo est toujours très semblable à celle-ci.
Les données importantes sont les différentes réponses possibles (et leur nombre).

(notez que sans l'option `-n 0`, seul un modèle aurait été montré. le `n`
est en fait la version courte de *nombre de modèle à afficher, ou 0 pour tous les afficher*.
Notez que, si des modèles n'ont pas été affichés à cause de cette option, clingo
le fera savoir en affichant un `+` à côté du nombre total de modèles calculés)

La première réponse (ou *modèle*, ou *answer set*, ou *ensemble réponse*),
contient uniquement l'atome b.
La seconde contient uniquement l'atome c.
Enfin, la dernière réponse contient uniquement l'atome a.


### Pourquoi cet ordre ?
Parce qu'en ASP, on travaille sur des *set* (answer *set* programming).
Les *set*, *ensemble* en français, au sens mathématique du terme,
sont des ensembles non ordonnés d'éléments uniques.

Les conséquences de ces propriétés sont les suivantes :

- les réponses ne sont nativement pas ordonnées (nous verrons que… mais c'est pour plus tard)
- un atome ne peut pas être *choisi* deux fois : soit il est vrai, soit il ne l'est pas. Il ne peut être vrai deux fois (car cela reviendrait à avoir deux fois le même élément dans un *set*)
- l'ordre des régles en ASP n'a pas d'importance (contrairement à Prolog, vous pouvez donc mélanger les lignes de votre programme sans que cela n'ait d'effet)

Gardez cela à l'esprit, car ces propriétés sont fondamentales dans
la construction mathématique derrière ASP, et donc dans les notions que l'on va voir après.


### Retour à nos moutons
Le programme traité par clingo est le *choix* suivant : `1 { a ; b ; c } 1`,
qui se traduit *un élément parmis a, b ou c*.
Le 1 à gauche est la borne minimale, par défaut égale à zéro.
Le 1 à droite est la borne maximale, par défaut l'infini.

Si le programme avait été `2 { a ; b ; c } 2`, j'aurais également eu trois modèles/réponses,
mais leur contenu exact aurait changé:  `a b`, `b c` et `c a` sont les trois ensembles possibles de deux éléments parmis a, b et c.

De la même manière, si le programme était `{ a ; b ; c }`, j'aurais eu 8 modèles.
Et si il était `{ a ; b ; c } 2`, j'aurais eu 7 modèles.
Pourquoi 8 et 7 ? Je vous laisse tester vous-même,
vous comprendrez tout de suite.

(remarquez que tout cela n'est que pure [combinatoire](https://fr.wikipedia.org/wiki/Combinatoire))


Aller, un dernier exemple pour la route, qui montre comment avoir un seul nb(X) vrai pour chaque answer set:

```asp
% On choisis un nombre entre 1 et 100.
1 { nb(1..100) } 1.
```

Vous pouvez (devriez) vérifier : nous obtenons bien 100 answer sets, chacun avec sa propre valeur de nb(X).


## Contraintes
Les contraintes ! On en a parlé longuement, et certainement que vous brûlez d'impatience à l'idée de les utiliser !

Reprenons notre dernier exemple, en ajoutant une contrainte qui écarte tous les modèles avec une valeur qui n'est pas multiple de 3 :

```asp
% On écarte tout modèle dont le nombre choisis n'est pas multiple de 3.
:- nb(N) ; N \ 3=0.
```

Premier constat, l'écriture d'une contrainte ressemble à celle d'une règle, à l'exception de la *tête*, qui est vide.
C'est exacement la description d'une contrainte dans la grammaire d'ASP: une règle sans tête.

Cela, mathématiquement, à un sens : la contrainte est une règle.
Hors, dans une règle, rappelez-vous : lorsque le *corps* est vrai, la *tête* est vraie.

Sauf que, dans le cas de la contrainte, la *tête* est vide : cela veux dire que si le *corps*
est vrai… rien ne peut être vrai !

C'est l'exact sens de la contrainte : si son *corps* est vrai, alors rien n'est vrai.
Il s'agit d'une contradiction fondamentale entre le fait que rien n'est vrai, et que le *corps* (et probablement d'autres atomes du programme) est vrai.
Par conséquent, le modèle est faux, et ne sera pas considéré par le solveur.

Ici `N\3 = 0` n'est vrai que si `N` est un multiple de 3.
Par conséquent, le *corps* de la contrainte est vrai lorsque nb(X) est vrai avec X un multiple de trois.
Donc le modèle est invalidé dans ce cas.
Donc, sur les 100 modèles précédemment générés, il n'en reste plus que 67: le nombre de nombre entre 1 et 100 qui n'est pas multiple de 3.



## Insatisfiabilité
Avec cette histoire de contraintes qui empêchent certains modèles d'exister,
on est en droit de se poser une question… Et si un problème n'est pas satisfiable,
c'est à dire qu'il n'existe pas de réponse ?

Et bien, accrochez vous à vos ceinture, c'est tout à fait possible:

```asp
a.  % a est vrai
:- a.  % a ne peut pas être vrai
```

Ceci est la contradiction la plus simple imaginable.
Et clingo réagit exactement comme il faut:

    clingo version 5.2.1
    Reading from program.lp
    Solving...
    UNSATISFIABLE

    Models       : 0
    Calls        : 1
    Time         : 5.189s (Solving: 0.00s 1st Model: 0.00s Unsat: 0.00s)
    CPU Time     : 0.000s

Le problème est bien **insatisfiable**, autrement dit, il n'a aucun answer set, aucune réponse possible.


## ∃ vs ∀
Vous connaissez certainement les deux opérateurs mathématiques suivant :
- ∃: *il existe*, c'est-à-dire qu'il y en a au moins un
- ∀: *pour tout*, c'est-à-dire que tous les éléments sont considérés

En ASP, ces signes cabalistiques n'apparaissent pas, mais leur sémantique apparaît visiblement.
Le premier, *il existe*, nous l'avons déjà utilisé : il est implicite dans les *corps* des règles.

Ainsi, dans `a(X):- p(X)`, il est dit que a(X) est vrai si *il existe* un p(X).
C'est particulièrement visible avec la règle `a:- p(X)`.
Ici, il suffit qu'un `p(X)` soit vrai, quelque soit la valeur de X, pour que `a` soit vrai.

Maintenant que l'on comprend bien que le *il existe* est partout par défaut, attaquons
le *pour tout* avec un exemple complet :

```asp
% J'ai 3 copains dans ma classe
copain(1..3).
% Parfois certains ne viennent pas à la récré
{ en_recre(1..3) } 3.
% On joue au ballon quand on est tous les quatre
on_joue_au_ballon:- en_recre(C): copain(C).
```

Cet exemple génère 8 answer sets, dont un seul contient `on_joue_au_ballon`.

Ici, le corps de la dernière règle implémente
la condition *en_recre(C) doit être vrai __pour tout__ les copains C.*
Autrement dit, si il existe un copain C tel que `en_recre(C)` est faux, alors la condition est brisée,
et le corps de la règle est faux, et par conséquent, on ne joue pas au ballon.


## Tokens
En ASP, il existe cinq types de tokens:
- les identifiants: par exemple `a`, `hello_world` ou `a_3_on_y_va`, mais pas `A`, `_`, `Arachide` ou `_case` (`[a-z][a-z0-9A-Z_]*`).
- les variables: un identifiant qui commence par une majuscule ou un underscore (`[A-Z_][a-z0-9A-Z_]*`).
- les nombres: seuls les nombres entiers sont gérés (`-?[0-9]+`).
- les textes: encadrés par des double-guillemets `"`, ils peuvent contenir n'importe quoi, sauf des double guillemets non précédés d'un antislash.
- les opérateurs: mathématiques (`+ - / * / \ ^ ..`) ou logiques (`; , :- : { }`)

Tout le langage ASP repose sur ces tokens.
Nous verrons qu'il existe un sur-ensemble du langage plus ou moins spécifique à clingo,
qui rentre dans la catégorie de la méta-programmation.
C'est la méta-programmation qui nous permettra de *tuner* la recherche de la solution,
par exemple en définissant quels atomes doivent être affichés dans les résultats,
ou définir les valeurs de constantes.




# En pratique !
Maintenant que l'on a les bases, nous allons (enfin !) pouvoir
attaquer de vrais problèmes.


TODO


# Métaprogrammation
Clingo (gringo) est capable de comprendre un sur-ensemble de l'ASP qui relève de la méta programmation.
Autrement dit, il existe des expressions valides qui ne sont pas de l'ASP, mais qui permettent de manipuler
le grounding ou le solving du programme.

Les directives de métaprogrammation commencent systématiquement par un `#`.
Nous allons ici voir les plus utiles. Pour plus d'exhaustivité,
je vous renvoie [au manuel de clingo](http://sourceforge.net/projects/potassco/files/guide/).


## #show
Il s'agit probablement de la directive la plus utilisée : il s'agit de déterminer
quels atomes seront affichés dans la sortie de clingo.

En effet, pour chaque answer set, clingo donne la liste complète des atomes
vrais. Dans certains cas, notamment quand vous avez beaucoup de données et d'atomes intermédiaires,
seuls quelques uns vous intéressent.

Par exemple, si vous codez un solveur de sudoku, les données (les cases déjà remplies)
ne changent pas, sont constantes d'un answer set à l'autre : vous ne voulez pas les afficher.

C'est là que `#show` intervient.

```asp
a(1;2;3).
b(X):- a(X).
#show b/1.
```

En runnant ce programme, avec ou sans la dernière ligne,
vous allez avoir *exactement* 1 modèle/answer set, contenant 3 ou 6 atomes selon les cas.

Pour être plus rigoureux, dans les deux cas les atomes vérifiés dans le modèle sont strictement identiques,
c'est juste qu'avec la dernière ligne, seuls 3 sont affichés (ceux ayant `b` comme prédicat).

Notez la manière dont on renseigne *l'ensemble des atomes de prédicat `b`*: en utilisant une notation très courante dans le monde de la programmation logique: `<prédicat>/<arité>`.
Si vous remplacez le 1 par un 2, clingo n'affichera rien : il va en effet afficher uniquement les atomes de prédicat `b` avec deux arguments, c'est-à-dire, dans ce cas précis, aucun.


### Le côté obscur de #show
Le programme suivant affiche 4 atomes, et aucun d'entre eux ne fait réellement partis du modèle trouvé par le solveur.

```asp
b(1).
#show b.
#show 23.
#show p(X): b(X).
```

Nous voyons ici trois usages différents de show.
Le premier et le second sont des moyens d'afficher des données, y comprit des nombres.

Le troisième montre qu'il est possible de faire quelques opérations logiques sur les règles à montrer.
Cela peut servir pour filtrer précisément les atomes à afficher, ou pour renommer les atomes
(ici, on renomme `b/1` en `p/1`).

Notez bien que ces usages de *show* sont *génératives* : elles ajoutent des atomes dans la réponse,
sans les ajouter dans le solving lui-même (essayez en ajoutant `c(X):- p(X).`, vous verrez que c/1 n'est pas vérifiable)


### Le #show impératif
Il existe une dernière forme pour cette directive : `#show.`.
Elle se traduit par *n'affique strictement que ce qui est demandé*.

Par exemple, si tous les shows de mon programme sont génératifs (cf section précédente),
comment faire pour n'afficher que ceux-là, et pas le reste du programme ?

```asp
a.
#show 23.
```

Ce programme va afficher dans l'unique modèle les atomes *a* et *23*.
Maintenant, si j'ajoute `#show.` quelque part…

```asp
a.
#show.
#show 23.
```

Paf ! Seul *23* est affiché. Pourquoi ? Parce que *a* n'a pas été explicitement rattaché au show.

En général, les directives `#show` se trouvent en fin de fichier (assez logiquement,
c'est la dernière chose qui est faite), et le premier *show* est généralement `#show.`.
C'est une habitude qu'on retrouve dans beaucoup de codes ASP.


## #const
Comme C utilise `#define` et `const`, clingo utilise un mélange des deux : `#const`.
Là s'arrête le parallèle, et commence un exemple :

```asp
#const ma_constante_avec_un_nom_a_rallonge = 42
#const m_constnte_sns_l_lettre_ = "a"

a(m_constnte_sns_l_lettre_).
a(ma_constante_sans_la_lettre_b).
p(X):- X=ma_constante_avec_un_nom_a_rallonge.
#show ma_constante_avec_un_nom_a_rallonge.
```

Nous avons ici deux constantes, nommées `ma_constante_avec_un_nom_a_rallonge`
et `m_constnte_sns_l_lettre_`, associées aux valeurs 42 et "a", respectivement.

Le `#const` se comporte comme le `#define` du C: lors du *grounding*,
toute occurence du nom de la constante sera remplacée par sa valeur.

Et tout comme le `#define` en C, il peut être réécrit lors de l'appel au compilateur.
Dans notre cas, lors de l'appel à clingo.

Ainsi, si vous voulez définir la valeur d'une constante lors du lancement du programme,
il suffit d'utiliser l'option `-c` : `clingo -c ma_constante_avec_un_nom_a_rallonge=23`.
Il s'agit donc d'un excellent moyen de proposer une personalisation d'un programme
sans avoir à tripoter le code.

Enfin, notez que tout comme le préprocesseur du C, clingo est malin :

```asp
#const cst = b.
cst(cst).
```

Ce code génère un answer set d'un atome qui est… `cst(b)`,
car le __`#const` agit sur les valeurs, pas les prédicats.__


## #minimize et #maximize
Le nerf de la guerre.

## #min et #max
Utiles.
## #count
Utile.
## #project
Un détail avec de l'importance.
## #program
Des fichiers dans des fichiers.





# Interface avec Python
ASP s'interface nativement avec Python et Lua. Je ne traite que de Python ici,
mais les principes sont exactement les même avec Lua.

## Embedding dans Python
Plutôt qu'appeler clingo pour tous nos cas de tests, et vérifier à la main si ils fonctionnent correctement,
ou juste si on a besoin d'appeler clingo plusieurs fois avec des traitements des résultats,
il est possible de le faire depuis Python.


### API officielle
Il existe un module officiel, qui est dans les sources du logiciel et que vous pouvez installer avec un `python setup.py install` standard.
Je n'utilise pas cette API en règle générale.


### Autres API
Une alternative est [pyasp](https://github.com/sthiele/pyasp).
Néanmoins, ce package et ne supporte pas clingo *seul*,
mais plutôt gringo et clasp comme deux binaires
séparés appelés séquentiellement.
Hors, dans les nouvelles versions du solveur, seul clingo est distribué.
Pyasp n'est donc (pour le moment) pas une alternative viable pour utiliser les versions les plus récentes.

L'autre alternative, que je vous conseille pour démarrer, est [clyngor](https://github.com/aluriak/clyngor).
C'est un module python on ne peux plus standard, disponible sur pypi,
et qui ne nécessite qu'une chose: que le binaire clingo soit dans votre $PATH.

Et normalement, c'est déjà fait :)


## Extending avec Python
Vous avez déjà étendu Python avec du C pour gagner un peu de performances ?
Eh bien, de la même manière, on peut mettre du Python (ou du Lua) dans ASP
pour profiter, pendant le solving même, de la puissance d'un langage impératif.


### Multi-shot solving
TODO

### Iterative solving
TODO




# Real-world application

## Golfing
Si vous ne connaissez pas [codegolf.stackexchange](https://codegolf.stackexchange.com),
il s'agit d'une des instances de stackexchange (la plus connue est probablement stackoverflow),
où les questions sont des challenges de code golf, c'est-à-dire des challenges où le but est de faire les programmes les plus courts possible,
indépendemment du language. Le score correspond au nombre de caractères dans le code ; le but est donc de minimiser ce score.

Par exemple, [**calculer le score du jeu boggle**](https://codegolf.stackexchange.com/questions/143213/score-a-game-of-boggle).
Nous allons faire celui-ci, car il est simple et nécessite un peu de python.

Nous allons voir qu'il est possible d'atteindre un score certes moins bon que
[python seul](https://codegolf.stackexchange.com/a/143218),
mais meilleurs que les langages les plus verbeux comme java.

### Principes
Chaque joueur possède un ensemble de mot uniques d'au moins 3 caractères.
Le score d'un joueur est la somme des valeurs de ses mots.
Un mot trouvé par un autre joueur vaux zéro.
Un mot de 3 ou 4 lettres vaux 1 point. 5 lettres, 2 points, 6 lettres, 3 points, 7 lettres, 5 points,
8 lettres ou plus, 11 points.

### Données
Les données seront encodées avec un prédicat qui associe un numéro de joueur et les mots qu'il a trouvé.
Les contraintes sur les mots nous servent bien : un mot ne peut pas apparaître plus d'une fois pour un joueur.

Suit le premier exemple donné dans la question :

```asp
player(1,("cat";"dog";"bird";"elephant")).  % score: 12
player(2,("bird";"dog";"coyote")).  % score: 3
player(3,("dog";"mouse")).  % score: 2
```

Calculons ensembles le score du joueur 1: *cat* donne 1 point, *dog* et *bird* ont été trouvés par d'autres joueurs et donnent donc 0 point, et *elephant* donne 11, soit un total de 12 points pour le premier joueur. De notre point de vue, cela veux dire que nous devons générer `score(1,12)`.

### Méthodologie

Déjà, nous avons besoin de déterminer quels sont les mots qui compterons pour le score.
Une première solution est de dire que 1 et 1 seul joueur à trouvé le mot.
L'autre solution est que, sachant un joueur l'ayant trouvé, tous les autres ne l'on pas trouvé.

```asp
unique(P,W):- 1 { player(_,W) } 1 ; player(P,W).
unique(P,W):- player(P,W) ; not player(P2,W): player(P2,_) P2!=P.
```

Maintenant que l'on sait quel mots doivent être comptés dans le score pour chaque joueur,
il est temps de se poser la question du score lui-même :

```asp
score(P,S):- S = #sum{L: unique(P,W), value(W,L)} ; player(P,_).
```
L'atome `score(P,S)` associe un joueur et son score final,
obtenu en faisant la somme des valeurs *L* des mots *W* qui sont uniques et associés au joueur.

Le problème de cette approche, c'est la génération automatique de `value(W,L)`.
En effet, en ASP, il n'est pas possible d'obtenir la longeur d'une chaîne.
Par conséquent, nous allons faire un peut de magie avec python:

```asp
#script (python)
def value(word):
    return len(word.string)
#end.
```
Notons que la valeur est facilement calculable en python, en utilisant le snippet utilisé [ici](https://codegolf.stackexchange.com/a/143218):

```asp
#script (python)
def value(word):
    return [1,1,2,3,5,11][min(len(word.string),8)-3]#end.#show s/2.
#end.
```

Et voilà, nous pouvons accéder à la valeur d'un mot W avec `@value(W)`. Que c'est magnifique !
Il serait possible d'encoder le mapping de la taille et de la valeur en ASP ainsi:

```asp
value(3,1).
value(4,1).
value(5,2).
value(6,3).
value(7,5).
n(8..99).
value(X,5):- n(X).
```
Mais l'inconvénient est triple : c'est long, il y a une génération de nombreux atomes inutiles,
et ça oblige à donner une limite supérieure à la taille des mots.

Donc, on garde la fonction python qui fait la totalité du mapping mot -> score,
ce qui nous permet de l'appeler dans la somme, et on obtient le code total suivant :

```asp
unique(P,W):- 1 { player(_,W) } 1 ; player(P,W).
score(P,S):- S = #sum{@value(W): unique(P,W)} ; player(P,_).
#script (python)
def value(word):
    return [1,1,2,3,5,11][min(len(word.string),8)-3]
#end.
```

Wow ! On obtient bien les bons scores pour chaque joueurs :
`score(1,12)`, `score(2,3)` et `score(3,2)`.

Maintenant que le programme fonctionne, il ne reste plus qu'à le *golfer*, et à compter les caractères. Voici donc notre script final, atteignant un score de 137 caractères, ce qui le place avant-avant dernier (devant PHP et Java) au moment où j'ai écrit ce programme :

```asp
u(P,W):-1{p(_,W)}1;p(P,W).s(P,S):-S=#sum{@v(W):u(P,W)};p(P,_).#script(python)
def v(w):return[1,1,2,3,5,11][min(len(w.string),8)-3]#end.
```

Notez que les données d'entrées doivent être encodées avec le prédicat `p` à place de `player`.
Aussi, la directive de script ignore le reste de sa ligne, par conséquent,
faire un one liner parfait est impossible ici.


## Construire un PC
Ici, on va s'intéresser à un jeu de lego : construire une machine.

Ce genre de programme s'organise autour de deux principaux programmes:
celui qui récupère les données, c'est-à-dire les pièces de pc disponibles,
comme par exemple les cartes graphiques, les processeurs, les boîtiers,…
et celui qui construit le pc à partir des pièces récupérées, c'est-à-dire
qui choisi quelles pièces utiliser.

Le mot-clef, vous l'aurez compris, c'est *choisir*, et il se trouve dans la seconde
catégorie. L'interface avec un distributeur de matériel informatique n'est pas
le sujet de ce tuto, donc on s'arrangera avec quelques données faites à la main.

Mais si un jour quelqu'un veux s'amuser, la première étape est tout à fait automatisable,
par exemple en tapant dans l'api d'un distributeur qui en propose une.


### Spécifications
Une machine est un ensemble de plusieurs pièces : CPU, GPU, RAM, carte mère, refroidissement, disque dur, SSD, boite, périphérique.
Chacune de ces *catégories* doit se voir assigner une (et une seule) pièce, ou éventuellement zéro si la catégorie est optionnelle
(par exemple, je peux vouloir un SSD *si possible* ; c'est donc optionnel)

Chaque pièce appartient donc à une catégorie, et possède un prix, des dépendances et des incompatibilités.
Aussi, elles auront chacune une note de *préférence* : je pourrais ainsi dire *je préfère la GPU 1080 à la 1070*
en mettant une plus grande préférence sur la première.

Enfin, et c'est là tout le sel : on ne veux pas dépasser un prix maximum.

### En clair
On veut un programme ASP qui, en considérant les pièces disponibles, nos préférences personnelles, les interdépendances
entre les pièces, et un prix maximum, soit capable de nous donner une bonne solution, voir la meilleure.

Là où ASP est génial, c'est qu'il n'y a pas besoin de connaître grand chose en heuristique pour résoudre ce genre de problème
(qui, j'en suis sûr, se réduit [au problème du sac-à-dos](https://fr.wikipedia.org/wiki/Problème%20du%20sac%20à%20dos), et par conséquent est NP-complet).

Le code le plus récent est disponible sur [le dépôt](https://github.com/aluriak/learning-ASP/blob/master/build-pc.lp).
Nous allons ici l'aborder point par point.


### Commentaires
Nous allons étudier le programme, découpé en 5 parties.
Les premières parties sont de la pure description,
nous allons donc nous contenter de décrire des faits,
comme par exemple *cette GPU est trop cool*,
ou *ce composant est incompatible avec celui-là*.

Les dernières parties vont implémenter le moteur réel, la partie du programme
qui va utiliser les faits pour en déduire une configuration valide d'ordinateur.
C'est ici que nous trouverons les contraintes et les directives de maximisation.


#### Données
Tout d'abord, nous déclarons les données que nous allons utiliser,
c'est-à-dire les pièces disponibles, pour chaque catégories, avec leur nom et leur score (qui représente à quel point la pièce nous intéresse).

```asp
component(gpu,"A",330,10).
```

Ici, le composant de catégorie GPU, sobrement nommé *A*, coûte 330€ et est noté 10/10,
autrement dit, cette GPU, c'est notre préférée.

Les deux autres GPU accessibles sont données avec les trois lignes suivantes.

```asp
component(gpu,"B",200,7).
component(gpu,"embedded graphic chipset",0,4).
require(gpu,"embedded graphic chipset",cpu,"C").
```

Les deux autres gpu étant moins bonnes, leurs notes sont moins hautes (voir nulle pour la *C*, mais il s'agit d'une puce graphique intel, ce n'est donc qu'une solution par défaut).

##### Dépendances
Notez l'atome `require/4`  qui nous permet de définir que la puce intégrée
nécessite le CPU *C*, et par conséquent (et la règle qui s'en assure sera vue plus tard
que le choix de cette GPU oblige à utiliser le processeur qui l'embarque (c'est assez logique, finalement).

Néanmoins, si on choisi le cpu *C*, nous ne sommes pas obligés de choisir la puce intégrée,
laissant le champs libre pour une autre carte graphique plus puissante.
(la logique étant que la puce intégrée ne prend pas l'emplacement de la carte graphique, c'est juste un module du processeur ; personnellement mon processeur possède une puce intégrée, mais je ne l'ai jamais utilisée, j'ai une vrai carte graphique à la place)

##### Les autres composants
CPU, RAM, SSD, HDD,… Tous vont passer dans la grande moulinette de l'ASP.
Je vous invite à regarder le code pour avoir une idée de toutes les pièces qui seront utilisées.




#### Préférences
Les choix concernant le build : pièces optionelles, importances relatives.
#### Connaissances du domaine
Pas très utilisé pour le moment, mais donne un exemple simple de ce qui pourrait y être placé.
#### Expansion des données
De l'interface haut niveau aux atomes pour la couche d'en dessous.
#### Modèle
C'est ici que le principal se passe.



### Aller plus loin
#### Attrapez les toutes
Déjà, une première étape, c'est effectivement de récupérer les données.
Évidemment, récupérer TOUTES les pièces possibles est un peu long,
alors avoir des informations en amont, notamment les prix minimaux et maximaux (globaux, et par catégorie)
permet déjà d'élaguer. En général, toute limitation est bonne à prendre : taille de la RAM, du stockage, nombre de cœurs…

Tout cela est facile à intégrer dans le programme ASP : il ne s'agit que de rajouter des pièces,
des préférences, voir des contraintes.


#### Dans le ¬Sephiroth
Une fois que les deux premières parties sont mises en place et travaillent ensembles,
vient l'étape de distribution.

Une manière de faire, c'est une interface web, où les utilisateurs peuvent checker
les pièces disponibles qui les intéressent, éventuellement faire un peu d'apprentissage pour proposer
des pièces intéressantes (si 80% des utilisateurs qui prennent 8Go de RAM choissisent aussi une 1080,
alors automatiquement proposer une 1080 à tout utilisateur qui prend 8Go de RAM).

La deuxième étape, c'est de faire tourner le solveur
(dans le navigateur du client grâce à du [webassembly](https://fr.wikipedia.org/wiki/WebAssembly)
parce qu'on vit dans le futur),
et de sortir les meilleurs *build* au client.

Et paf, vous vous faites connaître, et [r/buildapc](https://www.reddit.com/r/buildapc/)
devient votre source d'utilisateur principale.




## Résoudre un donjon de The Legend of Zelda


    % Dungeon objects.
    % onedoor(g).
    keydoor(g).
    keydoor(b;f).
    % door(D):- onedoor(D).
    door(D):- keydoor(D).
    key(c;e).
    % one(d).
    key(d).
    open(start).  % links starts the dungeon

    % Links between doors
    link(start,(b;c;d)).
    link(b,(e;f)).
    link(f,g;g,stop).


    % Doors next to open doors are accessible
    accessible(Door):- link(Open,Door) ; open(Open).

    % Doors with objects inside are opened freely.
    open(ObjDoor):- accessible(ObjDoor) ; key(ObjDoor).
    open(ObjDoor):- accessible(ObjDoor) ; oner(ObjDoor).

    % Doors that are opened using one non-used key.
    open(KeyDoor,Key):- accessible(KeyDoor) ; keydoor(KeyDoor) ; open(Key) ; key(Key) ;
                        not open(KeyDoor,OtherKey): key(OtherKey), OtherKey!=Key ;
                        not open(OtherDoor,Key): keydoor(OtherDoor), OtherDoor!=KeyDoor.

    % Doors that are opened using a reusable object.
    % open(OneDoor,One):- not open(OneDoor) ; accessible(OneDoor) ; open(One) ; one(One).
    % open(TwoDoor,Two):- not open(TwoDoor) ; accessible(TwoDoor) ; open(Two) ; two(Two).

    % Keep in mind which object opened which door.
    open(Door):- open(Door,_).



    #show.
    #show open/2.



# Liens
- [une page](http://www.hakank.org/answer%20set%20programming) très complète avec beaucoup d'exemples et de programmes avec explications
- N'hésitez pas à poser des questions sur ASP sur [stack-overflow](http://stackoverflow.com/questions/tagged/answer-set-programming).
- la page [potassco/teaching](https://potassco.org/teaching/) regorge de liens.
- une erreur ? une idée ? une question ? Ça se passe sur [le dépôt du blog](https://github.com/aluriak/blog-content)
- If you want to help for the english version, it's [here](https://github.com/aluriak/blog-content/blob/master/articles/tuto-asp_en.mkd)


*[ASP]: Answer Set Programming
*[answer set]: Un ensemble réponse, un modèle valide contenant un ensemble d'atomes qui sont tous vrais
*[answer set]: Un ensemble réponse, un modèle valide contenant un ensemble d'atomes qui sont tous vrais
*[CPU]: Computing Processing Unit, le processeur.
*[GPU]: Graphical Processing Unit, la carte graphique.
*[RAM]: Random Access Memory, la mémoire vive.
*[POO]: Programmation Orientée Objet, un paradigme où les concepts sont séparés et doivent interagir par envoie de messages
*[PF]: Programmation Fonctionnelle, un paradigme où les fonctions sont manipulées au même titre que les types de base
