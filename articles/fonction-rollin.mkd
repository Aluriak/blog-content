Title: La fonction Rollin — définition, étude, applications
Date: 2018-05-25
Tags: math, humor
Authors: Lucas Bourneuf
Summary: De la définition de la fonction Rollin, son étude, et son application
Slug: fonction-rollin
Lang: français
Translation: false
Status: draft


La fonction Rollin est décrite par [François Rollin](https://fr.wikipedia.org/wiki/Fran%C3%A7ois_Rollin),
dans [l'un de ses sketches](https://www.youtube.com/watch?v=26XJS8w44VE)
où il joue le personnage du Professeur Rollin.

Cette fonction permet à François Rollin de montrer la spécificité de l'année 2005,
car la fonction associe 3 à cette année là. [3, en Champagne](https://fr.wikipedia.org/wiki/Troyes).

Description de la fonction pour 2005 :

- je multiplie 2005 par -52, date de la bataille d'Alésia
- j'y ajoute 5 fois la population de Bethléem, soit 5 × 21947, ce qui donne 5475
- je divise ce chiffre par le numéro atomique du Tantale, 73
- j'obtiens 75 («tout rond, c'est déjà pas banal»)
- j'additionne le 7 et le 5, donc 12
- 1 + 2 = 3… en Champagne !

D'après le professeur, le même procédé appliqué à l'année 1922 donne 5.

Une première interprétation pour la fonction décrite est la suivante :

```python
def somme_chiffre(nb:int) -> int:
    return sum(map(int, str(nb)))

def rollin(annee:int) -> int:
    nb = ((-52 * annee) + (5 * 21947)) / 73
    while len(str(nb)) > 1:
        nb = somme_chiffre(nb)
    return nb

assert rollin(2005) == 3
assert rollin(1922) == 5
```

Ah, tout fonctionne pour le premier cas, 2005.
Néanmoins, une erreur est levée pour 1922, suggérant que notre fonction n'est pas celle du professeur.
Pas d'inquiétude cependant, nous connaissons le résultat attendu (5), et plusieurs manières pour améliorer notre interprétation.



# Décisions sur décimaux
L'erreur est question est dû à un problème concernant les nombres décimaux : `((-52 * 1922) + (5 * 21947)) / 73`
n'est pas un nombre entier : 134.12328767123287. Notre fonction ne fonctionne plus, et pire, le professeur ne nous a pas indiqué
comment la fonction devait se comporter lorsque la division renvoie un nombre décimal.

Une première zone d'ombre sur la définition de la fonction plane donc sur la gestion des nombres décimaux.
Voici trois moyens pour gérer la crise.

## Troncature
Définissons la fonction `somme_chiffre` légèrement différemment, par troncature de la partie décimale :
```python
def somme_chiffre(nb:int) -> int:
    return sum(map(int, str(int(nb))))
```
Maintenant, dans le cas de l'année 1922, nous obtenons 8 : en effet, la partie décimale étant ignorée, nous sommons les chiffres du nombre 134, soit 1 + 3 + 4 = 8.
Ça fonctionne, mais ce n'est pas en accord avec ce qu'indique le professeur. Raté.

## Retrait du point
Définissons la fonction `somme_chiffre` de telle manière que le point dans les nombres décimaux soit ignoré :
```python
def somme_chiffre(nb:int) -> int:
    return sum(map(int, str(nb).replace('.', '')))
```
Dans un tel cas, nous arrivons à 1+3+4+1+2+3+2+8+7+6+7+1+2+3+2+8+7=67, soit 6+7=13, donc 4. Ce n'est pas, bien que l'on s'en rapproche comme le requin d'un surfeur,
encore la solution indiquée par le professeur.

## Arrondis
Considérons que le professeur Rollin ne s'intéresse pas à des mondanités telles que l'exactitude des nombres flottants.
Après tout, Turing ne s'est pas intéressé à la complexité des machines du même nom, et deux décimales de pi sont suffisantes pour envoyer des cosmonautes sur la lune.

Question : quel arrondis permet à la fonction Rollin de trouver 5 pour 1922 ? Trouvons la réponse par brute-force :

```python
def somme_chiffre(nb:int) -> int:
    return sum(map(int, str(nb).replace('.', '')))

def rollin(annee, arrondis:int=0) -> int:
    nb = round(((-52 * annee) + (5 * 21947)) / 73, arrondis)
    while len(str(nb)) > 1:
        nb = somme_chiffre(nb)
    return nb

for arrondis in range(20):
    assert rollin(2005) == 3  # on vérifie qu'on est toujours ok
    if rollin(1922, arrondis) == 5:
        print(arrondis)
```
Et nous obtenons trois valeurs : 3, 6 et 11. Nous avons donc trois candidats. En appliquant pratiquement des théorèmes, tels que le rasoir d'Ockham ou le théorème du choix, nous pourrions dire que nous avons le choix de choisir parmi le plus économe, c'est-à-dire l'arrondis le plus tronquant.
Cependant, ce serait oublier que 2005 est l'année la plus spécifique, parmis toutes les années contemporaines du professeur
Rollin au moment de la définition de la fonction éponyme, c'est-à-dire de 1953 à 2005.
Par conséquent, afin de discriminer la meilleure solution, regardons le nombre d'années spécifiques en fonction de l'arrondis choisi :

```python
for arrondis in (3, 6, 11):
    print(str(arrondis).rjust(2), end=': ')
    for annee in range(1953, 2006):
        if rollin(annee, arrondis) == 5:
            print(annee, end='\t')
    print()
```

Et nous trouvons :

     3: 1956	1963	1970	1983	1990	1997
     6: 1961	1964	1975	1986	1989	2000
    11: 1956	1963	1970	1983	1990	1997

Ah. C'est embêtant, car, voyez-vous, les trois arrondis possibles proposent tout trois 6 années spécifiques. C'est fort embêtant. Notez que commencer non pas en 1953,
mais en 1922, ne change rien au problème. Il faut remonter plus loin, par exemple l'année où le russe devient la langue officielle de l’administration finlandaise,
ou l'année où Henri V est couronné empereur par le pape, aussi appelée par abus de langage, l'année de l'invasion des uns (sans h), afin de voir une asymétrie naître.

Nous noterons d'ailleurs dans de tels cas les intéressantes similitudes entre 3 et 11, laissant 6 sur le carreau de la différence.
Après réflexions et discussions avec un ami pas plus mathématicien que moi (mais néanmoins plus grand, peut-être cela n'a-t-il rien à voir),
il apparaît que cette propriété n'est pas un hasard,
car dans la première partie de la fonction de Rollin se trouve la division par 73, un nombre premier. Plus précisément,
il semblerait que [toute division](http://www.wolframalpha.com/input/?i=((-52+*+1922)+%2B+(5+*+21947))+%2F+73)
par le numéro atomique du tentale donne un nombre décimal de période 8, ainsi les arrondis à 3 et à 11 tronquent-ils la valeur au même index de la période, donc à la même valeur
(sauf dans des cas particuliers dûs à de malheureux arrondis), se traduisant, d'une manière qui m'échappe encore, en une équivalence lors de la somme en seconde partie de la fonction.

Rien d'exploitable, donc.



# Du multiplicateur de la population de Bethléem
Notons un détail qui ressemble à une coïncidence : nous multiplions la population de Bethléem par le dernier chiffre de l'année, 5.
Et si il ne s'agissait pas d'un hasard ?

Peut-être que la fonction Rollin utilise le dernier chiffre de l'année pour multiplier la population de Bethléem ?
Essayons !

```python
def somme_chiffre(nb:int) -> int:
    return sum(map(int, str(nb).replace('-', '').replace('.', '')))

def rollin(annee) -> int:
    nb = ((-52 * annee) + (int(str(annee)[-1]) * 21947))
    while len(str(nb)) > 1:
        nb = somme_chiffre(nb)
    return nb

assert rollin(2005) == 3
print(rollin(1922))  #  -> 3
```
Raté ! La fonction nous renvois 3. C'est fort embêtant. Mais peut-être avons nous raté le plus important : zéro + zéro + cinq est égal à cinq !
Ainsi, voilà une nouvelle proposition : le multiplicateur de la population de Bethléem est la somme des chiffres de l'année, à l'exception du premier.
Pour l'année 1922, nous devons donc multiplier la population de Bethléem non pas par 5, ni par 2, mais bien par 9+2+2=13 !

```python
def somme_chiffre(nb:int or str) -> int:
    return sum(map(int, str(nb).replace('-', '').replace('.', '')))

def rollin(annee, arrondis:int=0) -> int:
    nb = ((-52 * annee) + (somme_chiffre(str(annee)[1:]) * 21947)) / 73
    while len(str(nb)) > 1:
        nb = somme_chiffre(nb)
    return nb

assert rollin(2005) == 3
print(rollin(1922))  #  -> 5
```

Oui ! Nous avons trouvé ! Notre interprétation de la fonction de Rollin fonctionne ! Nous obtenons bien 5 !


# Autres pistes
## De la population de Bethléem
Le professeur Rollin est clair : la population de Bethléem est celle recensée en 2002, c'est-à-dire 3 ans avant l'année considérée.
1 ans avant, c'est les impôts, 2 ans avant on sait pas trop, 3 ans avant, c'est la population de Bethléem.

Deux cas existent :

- soit le choix de l'année 2002 est absolu, c'est-à-dire qu'il ne dépend pas de l'année. Dans ce cas, la fonction Rollin n'est calculable que depuis 2002, année de la liquidation de la compagnie aérienne Swissair. Suisse. Ce pourrait ne pas être un hasard.
- soit le choix de l'année 2002 est relatif à l'année considérée, peut-être simplement par une décrémentation de 3, indiquant que la population de Bethléem de 1919 doit être considérée pour calculer la fonction de Rollin.

Cette seconde solution est embêtante pour deux raisons :
- Bethléem ayant été fondée il y a très longtemps, et le recensement n'étant que très récent, cela rend la fonction de Rollin incalculable pour la majorité de son temps d'existance. Le rasoir d'Ockham nous indiquant que la solution la plus simple étant toujours la meilleure, nous devons nous abstenir de rajouter des incertitudes sur une fonction que l'on peut expliquer plus simplement.
- au risque de me répéter, la population de Bethléem devient un second argument pour la fonction. C'est chiant. Une belle fonction en mathématique, elle n'a qu'un seul paramètre, ou alors elle est enseignée dans les écoles d'ingénieurs.

Donc, bon, bof. Mais à garder dans un coin de la tête pour le jour où on devra oublier des choses.


## De l'interprétation de l'addition des chiffres
Dans sa démonstration, le professeur ne s'intéressant qu'à un cas particulier, il nous est impossible de déterminer
si l'addition des chiffres 7 et 5 qui font 12 et 1 et 2 qui font 3 doit se faire jusqu'à épuisement de chiffres,
ou uniquement deux fois.

La première solution à été retrouvée ici, mais en réalité une recherche approfondie serait bienvenue, montrant les effets que pourraient avoir un nombre donné d'addition des chiffres.
Peut-être deux est-il suffisant, peut-être en faut-il autant que la population à Troy. La question est ouverte.


# La fonction Rollin
Voici donc, au terme de nos recherches, notre interprétation la plus solide de la fonction Rollin :

```python
def somme_chiffre(nb:int) -> int:
    return sum(map(int, str(nb).replace('-', '').replace('.', '')))

def rollin(annee) -> int:
    nb = ((-52 * annee) + (sum(map(int, str(annee)[1:])) * 21947)) / 73
    while len(str(nb)) > 1:
        nb = somme_chiffre(nb)
    return nb

assert rollin(2005) == 3
assert rollin(1922) == 5
```

Nous pouvons maintenant nous poser la question de cette fonction dans sa représentation graphique !

Le code générant les visualisations qui suivent:

```python
import seaborn as sbn
import pandas as pd
import matplotlib.pyplot as plt

# Une palette commune sympa.
sbn.set()
sbn.set_palette('husl', 10)


# Représentation graphique de la fonction Rollin.
ANNEES = list(range(1922, 2005))
nb_par_annee = pd.DataFrame({
    'année': ANNEES,
    'nombre de Rollin': list(rollin(annee) for annee in ANNEES)
})
nb_par_annee = nb_par_annee.set_index('année')
nb_par_annee.plot()
plt.show()

# Association nombre de Rollin -> années
annee_par_nb = {}  # nombre de rollin -> {années}
for annee in ANNEES:
    nb = rollin(annee)
    annee_par_nb.setdefault(nb, []).append(annee)

# Nombre d'années pour chaque nombre de Rollin
nb_annee_par_nb = {"nombre d'années": [], 'nombre de Rollin': []}
for nb, annees in annee_par_nb.items():
    nb_annee_par_nb["nombre d'années"].append(len(annees))
    nb_annee_par_nb["nombre de Rollin"].append(nb)
nb_annee_par_nb = pd.DataFrame(nb_annee_par_nb)
nb_annee_par_nb.plot.bar(x='nombre de Rollin', y="nombre d'années")
plt.show()


# Boxplot, pour avoir une idée de la distribution des années
df_annee_par_nb = pd.DataFrame(
    {k: pd.Series(v) for k, v in annee_par_nb.items()},
    columns=tuple(annee_par_nb.keys()),
)
df_annee_par_nb.boxplot()
plt.show()
```

## Représentation scolaire

## Nombre d'années par nombre de Rollin
Première remarque : la fonction de Rollin ne suit pas, dans les cas étudiés, [la loi de Benford](https://fr.wikipedia.org/wiki/Loi%20de%20Benford).
Pour un économiste, c'est emmerdant, car la fonction de Rollin n'est pas utilisable pour la falsification de compte.

## Boxplot de la distribution des données


# De la particularité des années Rollin
Les années Rollin, donc, sont des années dont le nombre de Rollin, donné par la fonction de Rollin lorsqu'elle prend en entrée l'année considérée, est 3.
Ces années sont, des mots du professeur, Rollin également, *spécifiques*.

Le professeur n'ayant pas été très volubile à ce sujet, certainement dans un but pédagogique, nous nous devons d'étudier cela en détail. Afin d'étudier de manière complète
et neutre les spécificités des années Rollin, nous pourrions utiliser comme corpus les pages wikipédia qui listent, pour chaque année,
les grand achèvements de l'humanité et de son environnement.

Le corpus d'apprentissage sera donc récupéré selon [la méthode RACHE](http://www.la-rache.com/), c'est-à-dire avec un parsing des pages web
concernées de l'apannage d'un vomi de fin de soirée : dégueux mais simple.
Une fois les phrases récupérées, elles seront apprise par un modèle de Markov d'ordre 2 sur les mots, ou d'ordre 6 sur les lettres, car cela donne de bon résultats
sur le travail de Victor Hugo. En utilisant en mode génératif ce modèle de Markov ainsi généré, nous obtiendrons des phrases que d'aucun pensera d'aléatoire,
et que les poseurs de question impertinants qualifierons de «non sens infondé».

Néanmoins, le professeur Rollin n'ayant jamais tord, il est *évident* que les années Rollin portent une caractéristique. Si cette caractéristique a trait aux achèvements
de l'humanité et de son environnement, cela veut dire que cette caractéristique se trouvera dans le modèle de Markov,
et donc que ce même modèle génèrera des prédiction pour les prochaines années Rollin.
Sinon, on a démontré que les années Rollin n'ont pas en spécificité d'être liées à des évènements mondains.

Quoiqu'il en soit, nous pouvons créer un générateur à choses qui seront vraies plus tard.
